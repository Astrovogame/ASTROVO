<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>ASTROVO ‚Äì √©√©n‚Äëvinger arcade</title>
<link href="manifest_circle.json" rel="manifest"/>
<meta content="#121212" name="theme-color"/>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&amp;display=swap" rel="stylesheet"/>
<style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* Professioneel thema: donker en verfijnd kleurverloop */
            background: linear-gradient(180deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #fff;
            font-family: 'Montserrat', sans-serif;
        }
        canvas {
            display: block;
            background: transparent;
        }
        #overlay, #shopOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            backdrop-filter: blur(6px);
            background: rgba(0, 0, 0, 0.6);
        }

        /* Startscreen styling */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            backdrop-filter: blur(6px);
            background: rgba(0, 0, 0, 0.5);
            padding: 0 5%;
            box-sizing: border-box;
        }
        #startScreen h1 {
            font-size: 54px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        /* Titel voor uitlegsectie op het startscherm */
        #startScreen .sectionTitle {
            font-size: 28px;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 12px;
            color: #ffb74d;
        }
        #startScreen .description {
            font-size: 20px;
            max-width: 600px;
            margin-bottom: 32px;
            line-height: 1.5;
            opacity: 0.9;
        }
        #startScreen .stats {
            font-size: 18px;
            margin-bottom: 28px;
            color: #cfd8dc;
        }
        #startScreen button {
            margin: 8px;
            padding: 14px 32px;
            font-size: 22px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.1s ease;
        }
        #startScreen button:active {
            transform: translateY(2px);
        }
        #startScreen .primaryBtn {
            background: linear-gradient(145deg, #ff9800, #ffa733);
            color: #fff;
        }
        #startScreen .secondaryBtn {
            background: linear-gradient(145deg, #607d8b, #78909c);
            color: #fff;
        }
        /* Global button styles for other overlays */
        .primaryBtn {
            margin: 8px;
            padding: 14px 32px;
            font-size: 22px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.1s ease;
            background: linear-gradient(145deg, #ff9800, #ffa733);
            color: #fff;
        }
        .secondaryBtn {
            margin: 8px;
            padding: 14px 32px;
            font-size: 22px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.1s ease;
            background: linear-gradient(145deg, #607d8b, #78909c);
            color: #fff;
        }
        .primaryBtn:active, .secondaryBtn:active {
            transform: translateY(2px);
        }
        #overlay button,
        #shopOverlay button {
            margin: 8px;
            padding: 12px 24px;
            font-size: 18px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(145deg, #ff9800, #ffa733);
            color: #fff;
            cursor: pointer;
            transition: transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        #overlay button:hover,
        #shopOverlay button:hover {
            transform: translateY(-2px);
        }
        #skins {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin: 16px;
        }
        .skinItem {
            border: 2px solid #444;
            border-radius: 8px;
            padding: 12px;
            margin: 8px;
            min-width: 100px;
            cursor: pointer;
            transition: border-color 0.2s, transform 0.1s;
            background: rgba(255,255,255,0.05);
        }
        .skinItem:hover { transform: translateY(-2px); }
        .skinItem.unlocked { border-color: #ff9800; }
        .skinItem.current { border-color: #4caf50; }
    
        /* Pauzeknop en overlay */
        #pauseBtn{
            position:absolute;
            top: max(12px, env(safe-area-inset-top));
            right: max(12px, env(safe-area-inset-right));
            z-index: 5;
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 12px;
            background: rgba(0,0,0,0.45);
            color: #fff;
            font-size: 22px;
            line-height: 48px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(4px);
            display: none; /* alleen tonen tijdens het spelen */
        }
        #pauseBtn:active{ transform: translateY(1px); }
        #pauseOverlay{
            position:absolute;
            inset:0;
            display:none;
            align-items:center;
            justify-content:center;
            flex-direction:column;
            text-align:center;
            backdrop-filter: blur(6px);
            background: rgba(0,0,0,0.6);
            z-index: 10;
        }
        #pauseOverlay h2 { margin: 0 0 8px; font-size: 36px; }
        #pauseTimer { font-size: 20px; opacity: 0.9; margin-bottom: 18px; }
        #pauseOverlay .row { display:flex; gap:12px; }
        

        /* Score knop en overlay */
        #scoreBtn {
            padding: 10px 20px;
            margin-top: 8px;
            font-size: 18px;
            cursor: pointer;
        }
        #scoreOverlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            color: #fff;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            text-align: center;
        }
        #scoreOverlay h2 {
            font-size: 32px;
            margin-bottom: 12px;
        }
        #scoreOverlay ul {
            list-style: none;
            padding: 0;
            margin: 0 0 20px 0;
        }
        #scoreOverlay li {
            font-size: 20px;
            margin: 4px 0;
        }
        #scoreClose {
            padding: 8px 16px;
            font-size: 18px;
            cursor: pointer;
        }
        
</style>
<style>/* --- Compact Shop Modal --- */
#shopOverlay{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  padding: max(12px, env(safe-area-inset-top)) max(12px, env(safe-area-inset-right)) max(12px, env(safe-area-inset-bottom)) max(12px, env(safe-area-inset-left));
  backdrop-filter: blur(6px);
  background: rgba(0,0,0,0.6);
  z-index: 30;
}
#shopPanel{
  width: min(560px, 92vw);
  max-height: min(82vh, 900px);
  background: rgba(20,20,30,0.92);
  border-radius: 16px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.55);
  display:flex;
  flex-direction:column;
  overflow:hidden;
}
#shopHeader{
  padding: 14px 18px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}
#shopHeader h2{ margin:0 0 4px 0; }
#shopBody{
  padding: 12px 14px;
  overflow:auto;
}
#shopFooter{
  padding: 12px 16px;
  border-top: 1px solid rgba(255,255,255,0.08);
  display:flex;
  justify-content:center;
}
/* Skins grid tweaks so it never pushes the footer off-screen */
#skins{
  margin: 0;
  display:flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content:center;
}
.shopStatus{opacity:0.9;font-weight:600;}
.skinItem{
  min-width: 92px;
  padding: 10px;
  margin: 0;
}
@media (max-height: 620px){
  #shopPanel{ max-height: 76vh; }
  #shopHeader h2{ font-size: 20px; }
  #playerCoins{ font-size: 14px; }
  .skinItem{ min-width: 84px; padding: 8px; }
}</style></head>
<body>
<canvas id="game"></canvas>
<button aria-label="Pause" data-i18n="pause" id="pauseBtn" title="Pause">‚è∏</button>
<!-- Start scherm -->
<div id="startScreen">
<h1>ASTROVO</h1>
<!-- Stats: high score en coins -->
<div class="stats" id="statsLabel"></div>
<button class="primaryBtn" data-i18n="start" id="startBtn">Start</button>
<button class="secondaryBtn" id="multiplayerBtn">üéÆ Multiplayer</button>
<button class="secondaryBtn" data-i18n="scores" id="scoreBtn">üèÜ Scores</button>
<button class="secondaryBtn" data-i18n="shop" id="startShopBtn">Shop</button>
<button class="secondaryBtn" data-i18n="howTo" id="howToBtn">How to Play</button>
<button class="secondaryBtn" data-i18n="settings" id="settingsBtn">Settings</button>

<!-- Multiplayer UI & overlay canvas -->
<canvas id="mpCanvas" style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:12;"></canvas>
<div id="mpOverlay" style="display:none;position:absolute;inset:0;align-items:center;justify-content:center;text-align:center;background:rgba(0,0,0,0.6);backdrop-filter:blur(6px);z-index:25;">
  <div style="background:rgba(20,20,30,0.92);padding:16px 20px;border-radius:14px;max-width:420px;width:92vw;box-shadow:0 10px 30px rgba(0,0,0,0.45);">
    <h2 style="margin:0 0 12px;">Multiplayer</h2>
    <p style="margin-top:0;opacity:.85">Speel live tegen een andere speler. Jij bent je gekozen skin, de tegenstander is <strong>rood</strong>.</p>
    
      
    <div style="display:flex;gap:10px;margin-bottom:10px;flex-wrap:wrap;justify-content:center;">
      <input id="mpName" placeholder="Jouw naam" style="flex:1;min-width:160px;padding:10px;border-radius:10px;border:1px solid #444;background:#111;color:#fff;">
      <input id="mpRoomCode" placeholder="Code (bv. 7K3F)" style="width:140px;padding:10px;border-radius:10px;border:1px solid #444;background:#111;color:#fff;text-transform:uppercase;">
    </div>
    <div style="display:flex;gap:10px;margin-bottom:6px;flex-wrap:wrap;justify-content:center;">
      <button class="primaryBtn" id="mpJoinRoom">Meedoen</button>
      <button class="secondaryBtn" id="mpCreateRoom">Kamer maken</button>
      <button class="ghostBtn" id="mpClose">Terug</button>
    </div>
    
    <p id="mpStatus" style="margin-top:10px;opacity:.9;"></p>
  </div>
</div>

<!-- Uitleg overlay -->
<div data-i18n="howToTitle" id="infoOverlay" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;flex-direction:column;justify-content:center;align-items:center;text-align:center;backdrop-filter:blur(6px);background:rgba(0,0,0,0.6);padding:0 5%;box-sizing:border-box;">
<h2 style="font-size:32px;margin-bottom:16px;">How to Play</h2>
<p id="howToBody" style="font-size:20px;max-width:600px;line-height:1.5;margin-bottom:24px;">Avoid obstacles, collect coins, and survive as long as possible. Tap to switch direction.</p>
<button class="secondaryBtn" data-i18n="close" id="closeInfo">Close</button>
</div>
<div id="overlay">
<h1 data-i18n="gameOverTitle" id="overlayTitle"></h1>
<p id="overlayScore"></p>
<p id="overlayCoins"></p>
<button data-i18n="restart" id="restartBtn">Opnieuw spelen</button>
<button id="homeBtn">Back to menu</button>
<button class="secondaryBtn" id="shareBtn">Share score</button>
<button data-i18n="continueAd" id="continueBtn">Ga door (advertentie)</button>
<button data-i18n="shop" id="shopBtn">Shop</button>
</div>
<div id="shopOverlay"><div aria-labelledby="shopTitle" aria-modal="true" id="shopPanel" role="dialog"><div id="shopHeader"><h2 data-i18n="shop" id="shopTitle">Shop</h2><p data-i18n="coinsLabel" id="playerCoins"></p></div><div id="shopBody"><div id="skins"></div></div><div id="shopFooter"><button data-i18n="back" id="closeShop">Terug</button></div></div></div>
<!-- Instellingen overlay -->
<div data-i18n="settingsTitle" id="settingsOverlay" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;flex-direction:column;justify-content:center;align-items:center;text-align:center;backdrop-filter:blur(6px);background:rgba(0,0,0,0.6);">
<h2>Settings</h2>
<div class="settingRow">
<label style="font-size:20px;display:flex;align-items:center;gap:12px;">
<input data-i18n="music" id="musicToggle" style="transform:scale(1.5);" type="checkbox"/>
                Music
            </label>
</div>
<div class="settingRow" style="margin-top:12px;">
<label style="font-size:20px;display:flex;align-items:center;gap:12px;">
<input data-i18n="sfx" id="sfxToggle" style="transform:scale(1.5);" type="checkbox"/>
                Sound Effects
            </label>
</div>
<button class="secondaryBtn" data-i18n="close" id="closeSettings" style="margin-top:24px;">Close</button>
<div class="settingRow" style="margin-top:12px;">
<label style="font-size:20px;display:flex;align-items:center;gap:12px;">
<span data-i18n="languageLabel">Language</span>
<select id="langSelect" style="font-size:18px;padding:6px 10px;border-radius:8px;">
<option value="nl">Nederlands</option>
<option value="en">English</option>
</select>
</label>
</div>
</div>
<!-- Pauze overlay -->
<div data-i18n="pauseTitle" id="pauseOverlay">
<h2>Paused</h2>
<div data-i18n="pauseTimer" id="pauseTimer">Automatically resume over 30s</div>
<div class="row">
<button class="primaryBtn" data-i18n="resume" id="pauseContinue">Doorgaan</button>
<button class="secondaryBtn" data-i18n="quit" id="pauseQuit">Verlaten</button>
</div>
</div>
<!-- Score overlay -->
<div data-i18n="scoreboardTitle" id="scoreOverlay">
<h2 data-i18n="scoreboardTitle">Scorebord</h2>
<div data-i18n="highScore" id="highScoreLabel">Hoogste score: 0</div>
<h3 data-i18n="recentScores" id="recentScoresTitle">Laatst 5 scores</h3>
<ul id="recentScoresList"></ul>
<button data-i18n="back" id="scoreClose">Terug</button>
</div>
<script>
    (function() {
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
// --- 3D-ish visuals additions ---
let starLayers = []; // [{speed, stars:[{x,y,sz}]}]
let vignetteGrad = null;
function init3DVisuals() {
    // create 3 parallax layers, more stars on deeper layers
    const layers = [
        {count: 60, speed: 0.15},
        {count: 40, speed: 0.08},
        {count: 25, speed: 0.03},
    ];
    starLayers = layers.map((lay, i) => {
        const stars = [];
        for (let s=0; s<lay.count; s++) {
            stars.push({
                x: Math.random(), // normalized 0..1
                y: Math.random(),
                sz: (i+1) * (Math.random()*1.5 + 0.5) // size factor
            });
        }
        return { speed: lay.speed, stars };
    });
    vignetteGrad = null; // recompute on next draw (needs canvas size)
}

        let w, h;
        function resize() {
            w = window.innerWidth;
            h = window.innerHeight;
            canvas.width = w;
            canvas.height = h;
        }
        window.addEventListener('resize', resize);
        resize();
        
init3DVisuals();
// center of circle and radius
        let cx, cy, radius;
        // Game state
        let playerAngle;
        // angular speed per frame (radians). The player moves along the track; direction toggles between 1 and -1.
        let baseSpeed = 0.02;
        let direction;
        // radial obstacles will travel outward from the centre; their speed is computed from the radius on reset.
        let obstacleSpeed;
        let lives;
        let obstacles;
        let coins;
        let powerUps;
        let score;
        let collectedCoins;
        let running = false;
        let paused = false;
        let pauseDeadline = 0;
        let pauseTick = null;
        let pauseTimeout = null;
        let wasMusicPlaying = false;
        let lastObstacleSpawn;
        let lastCoinSpawn;
        let lastPowerUpSpawn;
        let nextPowerUpSpawnTime;
        let shieldActive;
        let shieldTime;
        // slow effect power-up variables
        let slowActive;
        let slowTime;
        let explosions;
        // arrays for visual effects
        let particles;
        let trail;
        // persistent storage
        let coinBank = parseInt(localStorage.getItem('cr_coins') || '0', 10);
        let purchasedSkins = JSON.parse(localStorage.getItem('cr_skins') || '[]');
        let currentSkin = localStorage.getItem('cr_currentSkin') || 'default';
        let highScore = parseInt(localStorage.getItem('cr_highScore') || '0', 10);
        let recentScores = [];
        try { recentScores = JSON.parse(localStorage.getItem('cr_recentScores') || '[]') || []; } catch(e) { recentScores = []; }
        if (!Array.isArray(recentScores)) recentScores = [];
        recentScores = recentScores.filter(n => typeof n === 'number' && isFinite(n));
        if (recentScores.length > 5) recentScores = recentScores.slice(0,5);
// extra lives are no longer purchasable; always start with 1 life
        let extraLives = 0;
        // clear any previously stored extra lives
        localStorage.removeItem('cr_extraLives');
        const skins = [
            { id: 'default', name: 'Default', color: '#29b6f6', price: 0 },
            { id: 'rood', name: 'Red', color: '#e53935', price: 50 },
            { id: 'groen', name: 'Green', color: '#43a047', price: 50 },
            { id: 'paars', name: 'Purple', color: '#8e24aa', price: 75 },
            { id: 'goud', name: 'Gold', color: '#fdd835', price: 100 },
            { id: 'oranje', name: 'Orange', color: '#ff5722', price: 75 },
            { id: 'cyaan', name: 'Cyan', color: '#00bcd4', price: 75 },
            { id: 'roze', name: 'Pink', color: '#ec407a', price: 80 },
            { id: 'wit', name: 'White', color: '#fafafa', price: 90 },
            { id: 'zwart', name: 'Black', color: '#212121', price: 90 },
            { id: 'indigo', name: 'Indigo', color: '#3f51b5', price: 90 }
        ];
        function resetGame() {
            // refresh 3D visuals when a new run starts
            init3DVisuals();

            cx = w / 2;
            cy = h / 2;
            // Vergroot de radius voor een betere vulling op mobiele schermen
            radius = Math.min(w, h) * 0.45;
            playerAngle = 0;
            direction = 1;
            // compute the speed at which radial obstacles travel outward from the centre
            obstacleSpeed = radius / 80;
            // always start with a single life
            lives = 1;
            obstacles = [];
            coins = [];
            powerUps = [];
            score = 0;
            collectedCoins = 0;
            running = false; // don't start running until start button is pressed
            lastObstacleSpawn = Date.now();
            lastCoinSpawn = Date.now();
            lastPowerUpSpawn = Date.now();
            shieldActive = false;
            shieldTime = 0;
            slowActive = false;
            slowTime = 0;
            explosions = [];
            particles = [];
            trail = [];
            // set next power-up spawn time to a random interval so dat ze minder frequent voorkomen
            nextPowerUpSpawnTime = Date.now() + 12000 + Math.random() * 4000;
        }
        function spawnObstacle() {
            // Maak een obstakel dat uit het midden naar buiten beweegt langs een willekeurige hoek
            const angle = Math.random() * Math.PI * 2;
            obstacles.push({ angle: angle, distance: 0, passed: false });
        }
        function spawnCoin() {
            const angle = Math.random() * Math.PI * 2;
            const lifespan = 4000; // 4 seconds
            coins.push({ angle: angle, life: lifespan });
        }
        function spawnPowerUp() {
            const angle = Math.random() * Math.PI * 2;
            const lifespan = 4000; // power-ups disappear after 4 seconds, net als coins
            // Randomly choose type: shield or slow (50/50 chance)
            const type = Math.random() < 0.5 ? 'slow' : 'shield';
            powerUps.push({ angle: angle, life: lifespan, type: type });
        }
        function update(dt) {
            if (!running || paused) return;
            const now = Date.now();
            // handle active shield duration
            if (shieldActive) {
                shieldTime -= dt;
                if (shieldTime <= 0) shieldActive = false;
            }
            // handle slow power-up duration
            if (slowActive) {
                slowTime -= dt;
                if (slowTime <= 0) slowActive = false;
            }
            // spawn radial obstacles: interval decreases slightly with score for increasing challenge
            // spawn radial obstacles: interval decreases with score and number of obstacles per spawn increases
            // Dynamische moeilijkheid: naarmate je score stijgt spawnen er vaker en meer vuurballen.
            // Start langzaam en verhoog de frequentie sneller dan voorheen. Het minimuminterval is 300 ms.
            // Maak het tempo rustiger: obstakels spawnen langzamer en nemen langzaam toe in aantal
            // Spawninterval en aantal obstakels zijn aangepast voor een rustigere opbouw.
            // In het begin verschijnen vuurballen slechts om de paar seconden.
            // Naarmate je score stijgt, daalt het interval langzaam en komen er pas later meer tegelijk.
            const obstacleInterval = Math.max(1000, 4000 - score * 15);
            if (now - lastObstacleSpawn > obstacleInterval) {
                // Voeg pas extra vuurballen toe bij elke 15 punten, tot maximaal 4
                const spawnCount = Math.min(1 + Math.floor(score / 15), 4);
                for (let j = 0; j < spawnCount; j++) {
                    spawnObstacle();
                }
                lastObstacleSpawn = now;
            }
            // spawn coin every 3 seconds
            if (now - lastCoinSpawn > 3000) {
                spawnCoin();
                lastCoinSpawn = now;
            }
            // spawn power-ups op willekeurige momenten. Ze verschijnen minder frequent (ongeveer elke 12‚Äì18 seconden).
            if (now > nextPowerUpSpawnTime) {
                spawnPowerUp();
                nextPowerUpSpawnTime = now + 12000 + Math.random() * 6000;
            }
            // update player angle according to current direction and base speed
            playerAngle += direction * baseSpeed;
            // normalize angle to [0, 2œÄ)
            if (playerAngle >= Math.PI * 2) playerAngle -= Math.PI * 2;
            if (playerAngle < 0) playerAngle += Math.PI * 2;
            // update coins (lifespan and collection)
            for (let i = coins.length - 1; i >= 0; i--) {
                const c = coins[i];
                c.life -= dt;
                if (c.life <= 0) {
                    coins.splice(i, 1);
                } else {
                    let diff = Math.abs(playerAngle - c.angle);
                    diff = Math.min(diff, Math.PI * 2 - diff);
                    if (diff < 0.18) {
                        // Determine coin screen position for particle effect
                        const coinX = cx + radius * Math.cos(c.angle);
                        const coinY = cy + radius * Math.sin(c.angle);
                        coins.splice(i, 1);
                        collectedCoins += 1;
                        // create a burst effect when collecting a coin
                        createParticles(coinX, coinY, '#ffd54f');
                        // play coin sound
                        playBeep(700);
                    }
                }
            }
            // update power-ups (lifespan and collection)
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                p.life -= dt;
                if (p.life <= 0) {
                    powerUps.splice(i, 1);
                } else {
                    // check collection
                    let diffP = Math.abs(playerAngle - p.angle);
                    diffP = Math.min(diffP, Math.PI * 2 - diffP);
                    if (diffP < 0.22) {
                        const puX = cx + radius * Math.cos(p.angle);
                        const puY = cy + radius * Math.sin(p.angle);
                        powerUps.splice(i, 1);
                        if (p.type === 'slow') {
                            activateSlow();
                            // gebruik blauwe deeltjes voor slow power-up
                            createParticles(puX, puY, '#81d4fa');
                        } else {
                            activatePowerUp();
                            // gebruik paarse deeltjes voor shield power-up
                            createParticles(puX, puY, '#ba68c8');
                        }
                    }
                }
            }
            // Bereken huidige snelheid van de vuurballen (trager tijdens slow-power-up)
            const currentObstacleSpeed = slowActive ? obstacleSpeed * 0.5 : obstacleSpeed;
            // update radial obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const ob = obstacles[i];
                // move outward
                ob.distance += currentObstacleSpeed;
                // check if crossing the track (distance >= radius)
                if (!ob.passed && ob.distance >= radius) {
                    // compute angular difference between player and obstacle
                    let diff = Math.abs(playerAngle - ob.angle);
                    diff = Math.min(diff, Math.PI * 2 - diff);
                    if (diff < 0.25) {
                        // collision
                        if (shieldActive) {
                            // consume shield but do not lose a life
                            shieldActive = false;
                            // create explosion effect
                            createExplosion(ob.angle);
                            obstacles.splice(i, 1);
                            playBeep(300);
                            continue;
                        } else if (lives > 0) {
                            lives--;
                            createExplosion(ob.angle);
                            obstacles.splice(i, 1);
                            // play collision sound
                            playBeep(250);
                            continue;
                        } else {
                            running = false;
                            createExplosion(ob.angle);
                            showOverlay(window.__t ? __t('gameOverTitle') : 'Game Over');
                            // play game over sound
                            playBeep(200);
                            return;
                        }
                    } else {
                        // successfully avoided
                        ob.passed = true;
                        score++;
                    }
                }
                // remove obstacle if it has travelled beyond the track
                if (ob.distance > radius + 30) {
                    obstacles.splice(i, 1);
                }
            }
            // add a trail particle following the player position
            const px = cx + radius * Math.cos(playerAngle);
            const py = cy + radius * Math.sin(playerAngle);
            // determine current skin colour for trail
            const skinObj = skins.find(s => s.id === currentSkin) || { color: '#29b6f6' };
            trail.push({ x: px, y: py, life: 0.8, color: skinObj.color });
            // update trail particles
            for (let i = trail.length - 1; i >= 0; i--) {
                const t = trail[i];
                t.life -= dt / 1000;
                if (t.life <= 0) trail.splice(i, 1);
            }
            // update burst particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.dx;
                p.y += p.dy;
                p.life -= dt / 1000;
                // slow down over time
                p.dx *= 0.98;
                p.dy *= 0.98;
                if (p.life <= 0) particles.splice(i, 1);
            }
            // increase base speed gradually with score to add difficulty, maar start langzamer en bouw zeer langzaam op
            baseSpeed = 0.015 + Math.min(0.03, score / 4000);
        }

        function activatePowerUp() {
            // activate a shield that lasts for 8 seconds
            shieldActive = true;
            shieldTime = 8000;
            // play power-up sound
            playBeep(900);
        }

        function activateSlow() {
            // Activate a slow-down effect that halves the obstacle speed for 7 seconds
            slowActive = true;
            slowTime = 7000;
            // play a lower pitch to indicate slow effect
            playBeep(450);
        }

        function createExplosion(angle) {
            const ex = cx + radius * Math.cos(angle);
            const ey = cy + radius * Math.sin(angle);
            explosions.push({ x: ex, y: ey, radius: 6, opacity: 1.0 });
        }
        
        // Safely move all collected coins this run into the persistent bank
        function bankCollectedCoins() {
            if (collectedCoins > 0) {
                coinBank += collectedCoins;
                try { localStorage.setItem('cr_coins', coinBank); } catch(e) {}
                collectedCoins = 0;
            }
        }


        // Create a burst of small particles at x,y with a given colour
        function createParticles(px, py, colour) {
            for (let i = 0; i < 12; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 1.5 + 0.5;
                particles.push({
                    x: px,
                    y: py,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    radius: Math.random() * 3 + 2,
                    life: 1.0,
                    color: colour
                });
            }
        }
        // --- helper renderers for 3D effect ---
function drawParallaxBackground(time) {
    const cw = canvas.width, ch = canvas.height;
    // Rebuild vignette when needed
    if (!vignetteGrad) {
        const gctx = ctx;
        const maxR = Math.hypot(w, h);
        vignetteGrad = gctx.createRadialGradient(w/2, h/2, maxR*0.2, w/2, h/2, maxR*0.9);
        vignetteGrad.addColorStop(0, 'rgba(0,0,0,0)');
        vignetteGrad.addColorStop(1, 'rgba(0,0,0,0.45)');
    }
    // subtle moving stars
    starLayers.forEach((lay, idx) => {
        ctx.save();
        ctx.globalAlpha = 0.35 - idx*0.07;
        lay.stars.forEach(st => {
            // drift horizontally over time
            const drift = ((time*lay.speed + st.y*1000) % 1000)/1000;
            const x = (st.x + drift) % 1.0;
            const px = x * w;
            const py = st.y * h;
            ctx.beginPath();
            ctx.arc(px, py, st.sz, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fill();
        });
        ctx.restore();
    });
    // vignette overlay
    ctx.save();
    ctx.fillStyle = vignetteGrad;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
}
function drawRing3D() {
    const ringWidth = Math.max(18, Math.min(w,h) * 0.018);
    // base shaded stroke
    const ringGrad = ctx.createRadialGradient(cx, cy, radius - ringWidth, cx, cy, radius + ringWidth);
    ringGrad.addColorStop(0, 'rgba(255,255,255,0.18)');
    ringGrad.addColorStop(0.5, 'rgba(180,180,220,0.08)');
    ringGrad.addColorStop(1, 'rgba(0,0,0,0.5)');
    ctx.strokeStyle = ringGrad;
    ctx.lineWidth = ringWidth;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI*2);
    ctx.stroke();
    // subtle inner rim highlight
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, radius - ringWidth*0.48, 0, Math.PI*2);
    ctx.stroke();
    // subtle outer rim shadow
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.arc(cx, cy, radius + ringWidth*0.48, 0, Math.PI*2);
    ctx.stroke();
}
function drawPlayerUFO(px, py, baseColor) {
    ctx.save();
    ctx.translate(px, py);
    // soft glow
    const glow = ctx.createRadialGradient(0,0,2,0,0,18);
    glow.addColorStop(0,'rgba(255,255,255,0.6)');
    glow.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();

    // saucer base
    const grd = ctx.createLinearGradient(0,-10,0,14);
    grd.addColorStop(0, '#d0d6ff');
    grd.addColorStop(1, '#6b78ff');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.ellipse(0, 6, 16, 8, 0, 0, Math.PI*2);
    ctx.fill();

    // colored rim (skin)
    ctx.fillStyle = baseColor || '#29b6f6';
    ctx.beginPath();
    ctx.ellipse(0, 2, 14, 6.5, 0, 0, Math.PI*2);
    ctx.fill();

    // glass dome
    const dome = ctx.createRadialGradient(-4,-6,2,0,-8,12);
    dome.addColorStop(0,'rgba(255,255,255,0.95)');
    dome.addColorStop(1,'rgba(180,220,255,0.35)');
    ctx.fillStyle = dome;
    ctx.beginPath();
    ctx.ellipse(0, -6, 9, 7, 0, 0, Math.PI*2);
    ctx.fill();
    // dome highlight
    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.arc(-3,-8,4,0,Math.PI*1.2);
    ctx.stroke();

    ctx.restore();
}
function drawStarObstacle(ox, oy, outer, inner) {
    ctx.save();
    ctx.translate(ox, oy);
    // soft glow
    const glow = ctx.createRadialGradient(0,0,0,0,0,outer*1.6);
    glow.addColorStop(0,'rgba(255,200,50,0.8)');
    glow.addColorStop(1,'rgba(255,200,50,0)');
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(0,0,outer*1.4,0,Math.PI*2); ctx.fill();

    ctx.rotate(performance.now()/1600);
    ctx.shadowColor = 'rgba(0,0,0,0.45)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetY = 3;

    ctx.beginPath();
    for (let i=0;i<10;i++){
        const r = (i%2===0)? outer : inner;
        const ang = i * Math.PI/5;
        ctx.lineTo(r*Math.cos(ang), r*Math.sin(ang));
    }
    ctx.closePath();
    const starGrad = ctx.createRadialGradient(0,0,0,0,0,outer);
    starGrad.addColorStop(0,'#fffbe6');
    starGrad.addColorStop(0.5,'#ffeb3b');
    starGrad.addColorStop(1,'#f57f17');
    ctx.fillStyle = starGrad;
    ctx.fill();
    ctx.restore();
}
function draw() {
    ctx.clearRect(0,0,w,h);
    drawParallaxBackground(performance.now()/1000);
    drawRing3D();

            // draw trail (fading circles following player) before obstacles
            trail.forEach(t => {
                ctx.save();
                ctx.globalAlpha = t.life * 0.6;
                ctx.fillStyle = t.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // draw particle bursts
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            // draw radial obstacles as sterren (stars) with glow
            obstacles.forEach(ob => {
                const ox = cx + ob.distance * Math.cos(ob.angle);
                const oy = cy + ob.distance * Math.sin(ob.angle);
                drawStarObstacle(ox, oy, 20, 9);
            });
            // draw player (3D UFO)
            { 
              const skinObj = skins.find(s => s.id === currentSkin) || { color: '#29b6f6' };
              const px = cx + radius * Math.cos(playerAngle);
              const py = cy + radius * Math.sin(playerAngle);
              drawPlayerUFO(px, py, skinObj.color);
            }
            
// draw coins
            coins.forEach(c => {
                const coinX = cx + radius * Math.cos(c.angle);
                const coinY = cy + radius * Math.sin(c.angle);
                const coinRadius = 10;
                const coinGrad = ctx.createRadialGradient(coinX - coinRadius * 0.3, coinY - coinRadius * 0.3, coinRadius * 0.3, coinX, coinY, coinRadius);
                coinGrad.addColorStop(0, '#fff8e1');
                coinGrad.addColorStop(0.5, '#ffd54f');
                coinGrad.addColorStop(1, '#ffb300');
                ctx.save();
                ctx.beginPath();
                ctx.arc(coinX, coinY, coinRadius, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fillStyle = coinGrad;
                ctx.fill();
                ctx.restore();
            });
            // draw power-ups
            powerUps.forEach(p => {
                const px = cx + radius * Math.cos(p.angle);
                const py = cy + radius * Math.sin(p.angle);
                ctx.save();
                ctx.translate(px, py);
                if (p.type === 'slow') {
                    // slow power-up: getekend als blauwe cirkel met swirl lijnen
                    const rad = 12;
                    const slowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, rad);
                    slowGrad.addColorStop(0, '#b3e5fc');
                    slowGrad.addColorStop(0.4, '#4fc3f7');
                    slowGrad.addColorStop(1, '#0288d1');
                    ctx.fillStyle = slowGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, rad, 0, Math.PI * 2);
                    ctx.fill();
                    // swirl lines to indicate slow effect
                    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        const inner = 4 + i * 2;
                        const startAngle = -Math.PI / 2 + i * (Math.PI / 3);
                        const endAngle = startAngle + Math.PI / 3;
                        ctx.arc(0, 0, inner, startAngle, endAngle);
                        ctx.stroke();
                    }
                } else {
                    // shield power-up: getekend als een schild met gouden tinten
                    ctx.beginPath();
                    // start bovenaan
                    ctx.moveTo(0, -14);
                    // rechter bovenhoek naar midden
                    ctx.lineTo(10, -4);
                    // rechterzijde naar onderpunt
                    ctx.lineTo(6, 8);
                    ctx.lineTo(0, 14);
                    // linkerzijde naar onderpunt
                    ctx.lineTo(-6, 8);
                    ctx.lineTo(-10, -4);
                    ctx.closePath();
                    // radial gradient voor het schild (van lichtgeel naar oranje)
                    const shieldGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 14);
                    shieldGrad.addColorStop(0, '#fff8e1');
                    shieldGrad.addColorStop(0.4, '#ffcc80');
                    shieldGrad.addColorStop(1, '#f57c00');
                    ctx.fillStyle = shieldGrad;
                    ctx.fill();
                }
                ctx.restore();
            });
            // draw player as een UFO: een ovale schotel met een koepel erboven
            const playerX = cx + radius * Math.cos(playerAngle);
            const playerY = cy + radius * Math.sin(playerAngle);
            const skin = skins.find(s => s.id === currentSkin);
            const color = skin ? skin.color : '#29b6f6';
            const pr = 15;
            ctx.save();
            ctx.translate(playerX, playerY);
            // drop shadow
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            // Draw the base of the UFO as an ellipse
            const baseW = pr * 2.4;
            const baseH = pr * 0.9;
            ctx.beginPath();
            ctx.ellipse(0, pr * 0.25, baseW, baseH, 0, 0, Math.PI * 2);
            // gradient for base: lighter on top, darker on bottom
            const baseGrad = ctx.createLinearGradient(0, pr * -0.2, 0, pr * 0.5);
            baseGrad.addColorStop(0, shadeColor(color, 40));
            baseGrad.addColorStop(0.5, color);
            baseGrad.addColorStop(1, shadeColor(color, -40));
            ctx.fillStyle = baseGrad;
            ctx.fill();
            // Draw a small dome on top of the base
            const domeR = pr * 0.8;
            ctx.beginPath();
            ctx.arc(0, -pr * 0.1, domeR, Math.PI, 0);
            // dome gradient: light on top fading to skin colour
            const domeGrad = ctx.createRadialGradient(0, -pr * 0.3, 0, 0, -pr * 0.1, domeR);
            domeGrad.addColorStop(0, '#ffffffaa');
            domeGrad.addColorStop(0.6, shadeColor(color, 20));
            domeGrad.addColorStop(1, shadeColor(color, -20));
            ctx.fillStyle = domeGrad;
            ctx.fill();
            ctx.restore();

            // draw shield if active around UFO
            if (shieldActive) {
                ctx.save();
                ctx.strokeStyle = 'rgba(173, 216, 230, 0.7)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(playerX, playerY, pr + 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // draw explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                const ex = explosions[i];
                ctx.save();
                // use globalAlpha for fade-out effect
                ctx.globalAlpha = ex.opacity;
                const exGrad = ctx.createRadialGradient(ex.x, ex.y, 0, ex.x, ex.y, ex.radius);
                exGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                exGrad.addColorStop(1, 'rgba(255, 112, 67, 0)');
                ctx.fillStyle = exGrad;
                ctx.beginPath();
                ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                // update explosion properties
                ex.radius += 2;
                ex.opacity -= 0.05;
                if (ex.opacity <= 0) {
                    explosions.splice(i, 1);
                }
            }
            // draw HUD only when the game is running
            if (running && !paused) {
                ctx.fillStyle = 'rgba(255,255,255,0.95)';
                ctx.font = 'bold 24px Montserrat, sans-serif';
                ctx.fillText((window.__t?__t('score'):'Score')+': ' + score, 20, 34);
                ctx.fillText((window.__t?__t('coinsLabel'):'Munten')+': ' + collectedCoins, 20, 70);
                ctx.fillText('Lives: ' + lives, 20, 106);
            }
        }
        function gameLoop() {
            const now = Date.now();
            let last = now;
            function loop() {
                const current = Date.now();
                const dt = current - last;
                last = current;
                if (running) update(dt);
                draw();
                requestAnimationFrame(loop);
            }
            loop();
        }
        // input: tap to wissel van richting (links/rechts)
        function tap() {
            if (!running || paused) return;
            // toggle direction between 1 (rechtsom) en -1 (linksom)
            direction = -direction;
            // emit small particles on direction change
            const px = cx + radius * Math.cos(playerAngle);
            const py = cy + radius * Math.sin(playerAngle);
            // use current skin color for particle colour
            const currentSkinObj = skins.find(s => s.id === currentSkin) || { color: '#29b6f6' };
            createParticles(px, py, currentSkinObj.color);
            playBeep(500);
        }
        canvas.addEventListener('mousedown', tap);
        canvas.addEventListener('touchstart', function(e) {
            tap();
            e.preventDefault();
        }, { passive: false });
        // UI elements
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayScore = document.getElementById('overlayScore');
        const overlayCoins = document.getElementById('overlayCoins');
        const restartBtn = document.getElementById('restartBtn');
        const continueBtn = document.getElementById('continueBtn');
        const homeBtn = document.getElementById('homeBtn');
        // Go back to the start screen and persist coins
        homeBtn.addEventListener('click', function() {
            // bank any coins collected this run
            try { bankCollectedCoins(); } catch (e) {}
            // hide overlays and stop game state
            overlay.style.display = 'none';
            running = false;
            paused = false; // ensure boolean
            // Hide pause UI if present
            try { hidePauseButton(); } catch (e) {}
            // Reset gameplay to a fresh state (so no leftover objects remain)
            try { resetGame(); } catch (e) {}
            // Show start screen + refresh stats
            const startScreen = document.getElementById('startScreen');
            if (startScreen) startScreen.style.display = 'flex';
            try { updateStatsLabel(); } catch (e) {}
        });
        
        const shopBtn = document.getElementById('shopBtn');
        const shopOverlay = document.getElementById('shopOverlay');
        
        // Score overlay logica
        const scoreBtn = document.getElementById('scoreBtn');
        const scoreOverlay = document.getElementById('scoreOverlay');
        const highScoreLabel = document.getElementById('highScoreLabel');
        const recentScoresList = document.getElementById('recentScoresList');
        const scoreClose = document.getElementById('scoreClose');

        function openScores(){
            highScoreLabel.textContent = (window.__t?__t('highScore'):'Hoogste score:') + ' ' + highScore;
            recentScoresList.innerHTML = '';
            if(recentScores.length===0){
                const li = document.createElement('li');
                li.textContent = '(No score yets)';
                recentScoresList.appendChild(li);
            } else {
                recentScores.slice(0,5).forEach(s=>{
                    const li = document.createElement('li');
                    li.textContent = s;
                    recentScoresList.appendChild(li);
                });
            }
            scoreOverlay.style.display = 'flex';
        }
        function closeScores(){
            scoreOverlay.style.display = 'none';
        }
        scoreBtn.addEventListener('click', openScores);
        scoreClose.addEventListener('click', closeScores);
    
        const playerCoinsLabel = document.getElementById('playerCoins');
        
        function updateHighScoreAndList(){
            if (typeof score !== 'undefined') {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('cr_highScore', highScore);
                }
                // read the list fresh from storage and update it safely
                let list;
                try { list = JSON.parse(localStorage.getItem('cr_recentScores') || '[]') || []; } catch(e) { list = []; }
                if (!Array.isArray(list)) list = [];
                list.unshift(score);
                if (list.length > 5) list.length = 5;
                localStorage.setItem('cr_recentScores', JSON.stringify(list));
                // also update the in-memory array so the Score overlay shows the new item without reload
                recentScores = list;
            }
        }
        
        // Pauzeknop + overlay
        const pauseBtn = document.getElementById('pauseBtn');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const pauseTimer = document.getElementById('pauseTimer');
        const pauseContinue = document.getElementById('pauseContinue');
        const pauseQuit = document.getElementById('pauseQuit');

        function showPauseButton() { pauseBtn.style.display = 'block'; }
        function hidePauseButton() { pauseBtn.style.display = 'none'; }

        function openPause() {
            if (!running || paused) return;
            paused = true;
            wasMusicPlaying = musicEnabled;
            stopMusic();
            pauseOverlay.style.display = 'flex';
            hidePauseButton();
            const total = 30000; // 30s
            pauseDeadline = Date.now() + total;
            function updateCountdown(){
                const ms = Math.max(0, pauseDeadline - Date.now());
                const s = Math.ceil(ms/1000);
                pauseTimer.textContent = 'Automatically resume over ' + s + 's';
                if (ms <= 0) {
                    resumeFromPause();
                }
            }
            updateCountdown();
            pauseTick = setInterval(updateCountdown, 200);
            // backup timeout in case setInterval is throttled
            pauseTimeout = setTimeout(resumeFromPause, total + 200);
        }
        function resumeFromPause() {
            if (!paused) return;
            paused = false;
            pauseOverlay.style.display = 'none';
            clearInterval(pauseTick); pauseTick = null;
            if (pauseTimeout) { clearTimeout(pauseTimeout); pauseTimeout = null; }
            if (wasMusicPlaying && musicEnabled) playMusicLoop();
            showPauseButton();
        }
        function quitToMenu() {
            paused = false;
            clearInterval(pauseTick); pauseTick = null;
            if (pauseTimeout) { clearTimeout(pauseTimeout); pauseTimeout = null; }
            pauseOverlay.style.display = 'none';
            hidePauseButton();
            running = false;
            // zet coins bij banken, net als bij restart (we bewaren wat je tijdens de run had gepakt)
            bankCollectedCoins();
            resetGame();
            startScreen.style.display = 'flex';
            updateStatsLabel();
        }
        pauseBtn.addEventListener('click', openPause);
        pauseContinue.addEventListener('click', resumeFromPause);
        pauseQuit.addEventListener('click', quitToMenu);
        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') openPause(); });

        

        // Settings UI
        const settingsOverlay = document.getElementById('settingsOverlay');
        const settingsBtn = document.getElementById('settingsBtn');
        const musicToggle = document.getElementById('musicToggle');
        const sfxToggle = document.getElementById('sfxToggle');
        const closeSettingsBtn = document.getElementById('closeSettings');
        // Load sound preferences from storage (default on)
        let musicEnabled = (localStorage.getItem('cr_music') || '1') === '1';
        let sfxEnabled = (localStorage.getItem('cr_sfx') || '1') === '1';
        musicToggle.checked = musicEnabled;
        sfxToggle.checked = sfxEnabled;
        function saveSoundSettings() {
            localStorage.setItem('cr_music', musicEnabled ? '1' : '0');
            localStorage.setItem('cr_sfx', sfxEnabled ? '1' : '0');
        }


        settingsBtn.addEventListener('click', function() {
            // open settings overlay
            startScreen.style.display = 'none';
            settingsOverlay.style.display = 'flex';
        });
        closeSettingsBtn.addEventListener('click', function() {
            settingsOverlay.style.display = 'none';
            // if the game hasn't started yet, show the start screen again
            if (!running) {
                startScreen.style.display = 'flex';
                updateStatsLabel();
            }
        });
        musicToggle.addEventListener('change', function() {
            musicEnabled = musicToggle.checked;
            saveSoundSettings();
            // start or stop the background music when toggled
            if (musicEnabled) { ensureAudioRunning().then(()=>playMusicLoop()); } else { stopMusic(); }
        });
        sfxToggle.addEventListener('change', function() {
            sfxEnabled = sfxToggle.checked;
            saveSoundSettings();
        });

        // simple audio feedback using WebAudio
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // --- Robust audio handling helpers (consolidated) ---
        async function ensureAudioRunning() {
            try {
                if (audioCtx.state !== 'running') {
                    await audioCtx.resume();
                }
            } catch (e) {}
        }
        function immediateRestartMusicIfNeeded() {
            if (typeof musicEnabled !== 'undefined' ? musicEnabled : true) {
                if (typeof stopMusic === 'function') stopMusic();
                ensureAudioRunning().then(()=>{ try { if (typeof playMusicLoop==='function') playMusicLoop(); } catch(e){} });
            }
        }
        ['pointerdown','touchstart','mousedown','keydown'].forEach(evt=>{
            window.addEventListener(evt, ()=>{
                ensureAudioRunning();
                try {
                    if (typeof musicEnabled==='undefined' || musicEnabled) {
                        if (typeof currentMusicSources!=='undefined' && typeof currentMusicTimeout!=='undefined') {
                            if (currentMusicSources.length===0 && !currentMusicTimeout && typeof playMusicLoop==='function') playMusicLoop();
                        }
                    }
                } catch(e){}
            }, { passive:true });
        });
        document.addEventListener('visibilitychange', ()=>{
            if (document.visibilityState === 'hidden') {
                try { if (typeof stopMusic==='function') stopMusic(); } catch(e){}
            } else {
                immediateRestartMusicIfNeeded();
            }
        });
        window.addEventListener('focus', immediateRestartMusicIfNeeded);
        window.addEventListener('pageshow', immediateRestartMusicIfNeeded);
        try {
            audioCtx.addEventListener('statechange', ()=>{
                if (audioCtx.state === 'running' && (typeof musicEnabled==='undefined' || musicEnabled)) {
                    if (typeof currentMusicSources!=='undefined' && currentMusicSources.length===0 && typeof playMusicLoop==='function') {
                        try { playMusicLoop(); } catch(e){}
                    }
                }
            });
        } catch(e) {}
        // --- end helpers ---
    
        // Keep track of scheduled music sources and timeout so we can stop them
        let currentMusicTimeout = null;
        let currentMusicSources = [];

        function playBeep(freq, duration = 0.12) {
            ensureAudioRunning();
            if (!sfxEnabled) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.value = freq;
            osc.type = 'triangle';
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.stop(audioCtx.currentTime + duration);
        }

        // Simple looping chiptune background music using WebAudio
        function playMusicLoop() {
            ensureAudioRunning();
            // stop any running loops
            stopMusic();
            if (!musicEnabled) return;
            const melody = [659, 587, 523, 587, 659, 659, 659, 523, 523, 523, 587, 587, 587, 659, 587, 523];
            const noteDuration = 0.25; // seconds
            const startTime = audioCtx.currentTime;
            melody.forEach((freq, idx) => {
                const osc = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.value = freq;
                osc.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                const t0 = startTime + idx * noteDuration;
                const t1 = t0 + noteDuration;
                gainNode.gain.setValueAtTime(0.02, t0);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t1);
                osc.start(t0);
                osc.stop(t1);
                currentMusicSources.push(osc);
            });
            // schedule next loop
            currentMusicTimeout = setTimeout(playMusicLoop, melody.length * noteDuration * 1000);
        }
        function stopMusic() {
            if (currentMusicTimeout) {
                clearTimeout(currentMusicTimeout);
                currentMusicTimeout = null;
            }
            currentMusicSources.forEach(src => {
                try { src.stop(); } catch (e) {}
            });
            currentMusicSources = [];
        }

        // Start music loop after audio functions are defined
        if (musicEnabled) {
            playMusicLoop();
        }
        const skinsContainer = document.getElementById('skins');
        const closeShopBtn = document.getElementById('closeShop');
        function showOverlay(title) {
            updateHighScoreAndList();
            if (typeof hidePauseButton === 'function') hidePauseButton();
            overlayTitle.textContent = title;
            overlayScore.textContent = 'Score: ' + score;
            const earned = collectedCoins;
            bankCollectedCoins();
            overlayCoins.textContent = (window.__t?__t('earnedCoins'):'Verdiende coins:') + ' ' + earned;
            overlay.style.display = 'flex';
            continueBtn.style.display = collectedCoins > 0 ? 'inline-block' : 'none';
            restartBtn.style.display = 'inline-block';
            shopBtn.style.display = 'none';
            if (typeof homeBtn !== 'undefined' && homeBtn) homeBtn.style.display = 'inline-block';
            // update high score if higher
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('cr_highScore', highScore);
            }
        }
        function hideOverlay() { overlay.style.display = 'none'; }
        function showShop() {
            hideOverlay();
            renderShop();
            shopOverlay.style.display = 'flex';
        }
        function hideShop() { shopOverlay.style.display = 'none'; }
        restartBtn.addEventListener('click', function() {
            bankCollectedCoins();
            hideOverlay();
            resetGame();
            // direct opnieuw starten
            startScreen.style.display = 'none';
            running = true;
            showPauseButton();
        });
        continueBtn.addEventListener('click', function() {
            overlayTitle.textContent = 'Advertentie afspelen...';
            overlayScore.textContent = '';
            overlayCoins.textContent = '';
            continueBtn.style.display = 'none';
            restartBtn.style.display = 'none';
            shopBtn.style.display = 'none';
            setTimeout(() => {
                overlay.style.display = 'none';
                if (coinBank >= 10) {
                    coinBank -= 10;
                    localStorage.setItem('cr_coins', coinBank);
                }
                // after reviving, start fresh coin counter for the rest of this round
                collectedCoins = 0;
                running = true;
            showPauseButton();
            }, 3000);
        });
        shopBtn.addEventListener('click', showShop);
        closeShopBtn.addEventListener('click', hideShop);
        function renderShop() {
            playerCoinsLabel.textContent = (window.__t?__t('yourCoins'):'Je coins:') + ' ' + coinBank;
            skinsContainer.innerHTML = '';
            skins.forEach(skin => {
                const div = document.createElement('div');
                div.classList.add('skinItem');
                if (purchasedSkins.includes(skin.id) || skin.price === 0) {
                    div.classList.add('unlocked');
                }
                if (skin.id === currentSkin) {
                    div.classList.add('current');
                }
                const owned = (purchasedSkins.includes(skin.id) || skin.price === 0);
const statusLabel = owned ? (skin.id === currentSkin ? 'Current' : 'Select') : '';
div.innerHTML = `<strong>${skin.name}</strong><br>${owned ? `<span class="shopStatus">${statusLabel}</span>` : `${(window.__t?__t('price'):'Prijs')}: ${skin.price} ${(window.__t?__t('coinsWord'):'munten')}`}`;

                div.style.borderColor = skin.id === currentSkin ? '#4caf50' : ((purchasedSkins.includes(skin.id) || skin.price === 0) ? '#ff9800' : '#444');
                div.addEventListener('click', function() {
                    if (skin.price === 0 || purchasedSkins.includes(skin.id)) {
                        currentSkin = skin.id;
                        localStorage.setItem('cr_currentSkin', currentSkin);
                        renderShop();
                    } else {
                        if (coinBank >= skin.price) {
                            coinBank -= skin.price;
                            purchasedSkins.push(skin.id);
                            localStorage.setItem('cr_coins', coinBank);
                            localStorage.setItem('cr_skins', JSON.stringify(purchasedSkins));
                            renderShop();
                        } else {
                            alert((window.__t?__t('notEnoughCoins'):'Niet genoeg coins!'));
                        }
                    }
                });
                skinsContainer.appendChild(div);
            });
        }
        resetGame();
        gameLoop();

        // Start screen logic
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const startShopBtn = document.getElementById('startShopBtn');
        const statsLabel = document.getElementById('statsLabel');
        function updateStatsLabel() {
            // toon highscore en huidige coins
            const scoreText = highScore > 0 ? `Beste score: ${highScore}` : 'No score yet';
            statsLabel.textContent = `${scoreText} ¬∑ Coins: ${coinBank}`;
        }
        updateStatsLabel();
        startBtn.addEventListener('click', function() {
            startScreen.style.display = 'none';
            resetGame();
            running = true;
            showPauseButton();
        });
        startShopBtn.addEventListener('click', function() {
            startScreen.style.display = 'none';
            renderShop();
            shopOverlay.style.display = 'flex';
        });
        // When closing shop from start, show start screen again
        closeShopBtn.addEventListener('click', function() {
            if (!running && startScreen.style.display === 'none') {
                // returning from shop before game start
                startScreen.style.display = 'flex';
                updateStatsLabel();
            }
        });

        // Uitleg overlay logic
        const howToBtn = document.getElementById('howToBtn');
        const infoOverlay = document.getElementById('infoOverlay');
        const closeInfoBtn = document.getElementById('closeInfo');
        howToBtn.addEventListener('click', function() {
            // Hide start screen and show the uitleg overlay
            startScreen.style.display = 'none';
            infoOverlay.style.display = 'flex';
        });
        closeInfoBtn.addEventListener('click', function() {
            // Hide info overlay
            infoOverlay.style.display = 'none';
            // Show start screen again if game has not started yet
            if (!running) {
                startScreen.style.display = 'flex';
                updateStatsLabel();
            }
        });
    })();
    // Register service worker for PWA
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('service-worker.js').catch(function(err) {
                console.log('ServiceWorker registratie mislukt:', err);
            });
        });
    }
    // Helper to darken/lighten hex color
    function shadeColor(hex, amount) {
        const num = parseInt(hex.replace('#',''),16);
        let r = (num >> 16) + amount;
        let g = ((num >> 8) & 0x00FF) + amount;
        let b = (num & 0x0000FF) + amount;
        r = Math.max(Math.min(255, r), 0);
        g = Math.max(Math.min(255, g), 0);
        b = Math.max(Math.min(255, b), 0);
        return '#' + (g | (b << 8) | (r << 16)).toString(16).padStart(6,'0');
    }
    </script>
<script>
// ===== Simple i18n =====
(function(){
  const STRINGS = {
    nl: {
      yourCoins: "Jouw coins:",
      price: "Prijs:",
      coinsSuffix: "munten",
      notEnoughCoins: "Niet genoeg coins!",
      leaderboardTitle: "Scorebord",
      coinsEarned: "Munten verdiend:",
    
      start: "Start",
      scores: "üèÜ Scores",
      shop: "Winkel",
      howTo: "Uitleg",
      settings: "Instellingen",
      pause: "Pauze",
      close: "Sluiten",
      gameOverTitle: "Game Over",
      restart: "Opnieuw spelen",
      continueAd: "Ga door (advertentie)",
      selected: "Geselecteerd",
      select: "Selecteren",
      coinsLabel: "Coins", yourCoins:"Je coins:", price:"Prijs", coinsWord:"munten", earnedCoins:"Verdiende coins:", score:"Score", notEnoughCoins:"Niet genoeg coins!", howToBody:`Je bestuurt een kleine UFO die automatisch rond de cirkel vliegt. Tik op het scherm om van richting te wisselen en ontwijk de stervormige obstakels die vanuit het midden naar buiten bewegen. Het spel bouwt rustig op: obstakels komen steeds vaker naarmate je score stijgt, maar het tempo blijft beheersbaar. Onderweg verschijnen coins en twee soorten power‚Äëups: een <strong>schild</strong> (gouden schild‚Äëicoon) dat je √©√©n botsing laat overleven, en een <strong>vertrager</strong> (blauwe swirl‚Äëcirkel) die de snelheid van de obstakels tijdelijk halveert. Pak ze snel, want net als coins verdwijnen power‚Äëups na enkele seconden. Met verzamelde coins kun je schilden aanschaffen en nieuwe skins voor je UFO ontgrendelen.`,
      settingsTitle: "Instellingen",
      music: "Muziek",
      sfx: "Geluidseffecten",
      languageLabel: "Taal",
      pauseTitle: "Pauze",
      pauseTimer: "Automatically resume over 30s",
      resume: "Doorgaan",
      quit: "Verlaten",
      scoreboardTitle: "Scorebord",
      highScore: "Hoogste score:",
      back: "Terug",
      howToTitle: "Uitleg",
      title: "ASTROVO ‚Äì √©√©n‚Äëvinger arcade"
    },
    en: {
      yourCoins: "Your coins:",
      price: "Price:",
      coinsSuffix: "coins",
      notEnoughCoins: "Not enough coins!",
      leaderboardTitle: "Leaderboard",
      coinsEarned: "Coins earned:",
    
      start: "Start",
      scores: "üèÜ Scores",
      shop: "Shop",
      howTo: "How to Play",
      settings: "Settings",
      pause: "Pause",
      close: "Close",
      gameOverTitle: "Game Over",
      restart: "Play Again",
      continueAd: "Continue (ad)",
      selected: "Selected",
      select: "Select",
      coinsLabel: "Coins", yourCoins:"Your coins:", price:"Price", coinsWord:"coins", earnedCoins:"Coins earned:", score:"Score", notEnoughCoins:"Not enough coins!", howToBody:`You control a small UFO that automatically flies around the circle. Tap the screen to switch direction and avoid star‚Äëshaped obstacles that move outward from the center. The game ramps up gently: obstacles appear more often as your score increases, but the pace stays manageable. Along the way, coins and two power‚Äëups appear: a <strong>shield</strong> (gold shield icon) that lets you survive one collision, and a <strong>slowdown</strong> (blue swirl) that temporarily halves obstacle speed. Grab them quickly ‚Äî like coins, power‚Äëups disappear after a few seconds. Use collected coins to buy shields and unlock new skins for your UFO.`,
      settingsTitle: "Settings",
      music: "Music",
      sfx: "Sound effects",
      languageLabel: "Language",
      pauseTitle: "Paused",
      pauseTimer: "Auto‚Äëresume in 30s",
      resume: "Resume",
      quit: "Quit",
      scoreboardTitle: "Leaderboard",
      highScore: "High score:",
      back: "Back",
      howToTitle: "How to Play",
      title: "ASTROVO ‚Äì one‚Äëfinger arcade",
      recentScores: "Last 5 scores"
    }
  };
  function getLang(){ return localStorage.getItem('cr_lang') || 'en'; }
  function setLang(lang){
    localStorage.setItem('cr_lang', lang);
    applyI18n();
  }
  function t(key){
    const lang = localStorage.getItem('cr_lang') || 'en';
    return (STRINGS[lang] && STRINGS[lang][key]) || STRINGS.nl[key] || key;
  }
  function applyI18n(){
    const lang = localStorage.getItem('cr_lang') || 'en';
    document.documentElement.lang = lang;
    document.title = t('title');
    // update labeled elements
    const map = {
      startBtn: 'start',
      scoreBtn: 'scores',
      startShopBtn: 'shop',
      howToBtn: 'howTo',
      settingsBtn: 'settings',
      pauseBtn: 'pause',
      closeInfo: 'close',
      restartBtn: 'restart',
      continueBtn: 'continueAd',
      shopBtn: 'shop',
      closeShop: 'close',
      closeSettings: 'close',
      pauseContinue: 'resume',
      pauseQuit: 'quit',
      scoreClose: 'back'
    };
    Object.keys(map).forEach(id=>{
      const el=document.getElementById(id);
      if(el) el.textContent = t(map[id]);
    });
    const pauseOverlay = document.querySelector('#pauseOverlay h2');
    if (pauseOverlay) pauseOverlay.textContent = t('pauseTitle');
    const pauseTimer = document.getElementById('pauseTimer');
    if (pauseTimer) pauseTimer.textContent = t('pauseTimer');
    const settingsTitle = document.querySelector('#settingsOverlay h2');
    if (settingsTitle) settingsTitle.textContent = t('settingsTitle');
    const howToTitle = document.querySelector('#infoOverlay h2');
    if (howToTitle) howToTitle.textContent = t('howToTitle');
    const howToBody = document.getElementById('howToBody');
    if (howToBody) howToBody.innerHTML = t('howToBody');
    
    const shopTitle = document.querySelector('#shopOverlay h2');
    if (shopTitle) shopTitle.textContent = t('shop');
    const shopCoins = document.getElementById('playerCoins');
    if (shopCoins){
      // preserve number of coins
      const num = (shopCoins.textContent.match(/\d+/)||['0'])[0];
      shopCoins.textContent = t('yourCoins') + ' ' + num;
    }
    const priceLabels = document.querySelectorAll('.price');
    priceLabels.forEach(pl=>{
      const num = (pl.textContent.match(/\d+/)||['0'])[0];
      pl.textContent = t('price') + ' ' + num + ' ' + t('coinsSuffix');
    });
    const scoreOverlayTitle = document.querySelector('#scoreOverlay h2');
    if (scoreOverlayTitle) scoreOverlayTitle.textContent = t('leaderboardTitle');
    
    const scoreTitle = document.querySelector('#scoreOverlay h2');
    if (scoreTitle) scoreTitle.textContent = t('scoreboardTitle');
    const recentTitle = document.getElementById('recentScoresTitle');
    if (recentTitle) recentTitle.textContent = t('recentScores');
    const pc = document.getElementById('playerCoins');
    if (pc) { try { const coins = parseInt(localStorage.getItem('cr_coins')||'0',10); pc.textContent = t('yourCoins') + ' ' + coins; } catch(e){ pc.textContent = t('yourCoins'); } }
    const highLabel = document.getElementById('highScoreLabel');
    if (highLabel){
      // keep number if present
      const num = (highLabel.textContent.match(/\d+/)||['0'])[0];
      highLabel.textContent = t('highScore') + ' ' + num;
    }
    const pauseBtn = document.getElementById('pauseBtn');
    if (pauseBtn){ pauseBtn.setAttribute('title', t('pause')); pauseBtn.setAttribute('aria-label', t('pause'));}
    const langSelect = document.getElementById('langSelect');
    if (langSelect) langSelect.value = lang;
  }
  // Expose t for game code
  window.__t = t;
  window.__applyI18n = applyI18n;
  window.__setLang = setLang;
  document.addEventListener('DOMContentLoaded', function(){
    if(!localStorage.getItem('cr_lang')){ localStorage.setItem('cr_lang','en'); }
    const sel=document.getElementById('langSelect');
    if (sel){
      sel.addEventListener('change', e=> setLang(e.target.value));
    }
    applyI18n();
  });
})();


// --- Share/recording: capture 5s of the canvas and share/download ---
async function shareScoreRecording(ms=5000){
    try{
        const canvasEl = document.getElementById('game') || document.querySelector('canvas');
        if(!canvasEl || !canvasEl.captureStream){
            alert('Schermopname wordt niet ondersteund op dit apparaat.');
            return;
        }
        const stream = canvasEl.captureStream(60);
        let mime = '';
        if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) mime = 'video/webm;codecs=vp9';
        else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) mime = 'video/webm;codecs=vp8';
        else if (MediaRecorder.isTypeSupported('video/webm')) mime = 'video/webm';
        else if (MediaRecorder.isTypeSupported('video/mp4')) mime = 'video/mp4'; // iOS might not allow this via MediaRecorder
        const rec = new MediaRecorder(stream, mime ? {mimeType: mime} : undefined);
        const chunks = [];
        rec.ondataavailable = e => { if(e.data && e.data.size) chunks.push(e.data); };
        const stopped = new Promise((resolve, reject) => {
            rec.onstop = resolve;
            rec.onerror = ev => reject(ev.error || new Error('Record error'));
        });
        rec.start();
        // Provide a gentle pulse on the overlay so the video "has motion"
        let pulse = true;
        const overlayScoreEl = document.getElementById('overlayScore');
        const overlayTitleEl = document.getElementById('overlayTitle');
        const pulseTimer = setInterval(()=>{
            if(overlayScoreEl){ overlayScoreEl.style.transform = pulse ? 'scale(1.03)' : 'scale(1)'; }
            if(overlayTitleEl){ overlayTitleEl.style.opacity = pulse ? '0.9' : '1'; }
            pulse = !pulse;
        }, 350);
        await new Promise(r=>setTimeout(r, ms));
        clearInterval(pulseTimer);
        rec.stop();
        await stopped;
        const blob = new Blob(chunks, {type: mime || 'video/webm'});
        const fileName = `astrovo-score-${Date.now()}.webm`;
        const file = new File([blob], fileName, {type: blob.type});
        // Try native share first (best UX on mobile)
        if (navigator.canShare && navigator.canShare({files:[file]})) {
            await navigator.share({
                title: 'Mijn ASTROVO score',
                text: (document.getElementById('overlayScore')?.textContent || 'Kijk mijn score!'),
                files: [file]
            });
        } else if (navigator.share) {
            // Fallback: share with url to the blob
            const url = URL.createObjectURL(blob);
            await navigator.share({
                title: 'Mijn ASTROVO score',
                text: (document.getElementById('overlayScore')?.textContent || 'Kijk mijn score!'),
                url
            });
            URL.revokeObjectURL(url);
        } else {
            // Final fallback: offer a download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
            alert('De opname is als videobestand gedownload. Je kunt het nu zelf delen.');
        }
    }catch(err){
        console.error(err);
        alert('Delen mislukt: ' + (err.message || err));
    }
}

(function(){
  const shareBtn = document.getElementById('shareBtn');
  if (shareBtn){
    shareBtn.addEventListener('click', async ()=>{
      // Neem 5 seconden op
      await shareScoreRecording(5000);
    });
  }
})();



// --- Share score als afbeelding (PNG) met watermerk en PR-tekst ---
async function shareScoreImage(){
  try{
    const canvasEl = document.getElementById('game') || document.querySelector('canvas');
    if(!canvasEl){ alert('Canvas niet gevonden.'); return; }
    const w = canvasEl.width, h = canvasEl.height;
    const off = document.createElement('canvas');
    off.width = w; off.height = h;
    const octx = off.getContext('2d');
    octx.drawImage(canvasEl, 0, 0, w, h);

    const scoreText = (document.getElementById('overlayScore')?.textContent || '').trim() || 'Score';
    const titleText = (document.getElementById('overlayTitle')?.textContent || 'ASTROVO').trim();

    octx.save();
    octx.font = Math.round(h*0.045)+'px Montserrat, sans-serif';
    octx.textAlign = 'center';
    octx.textBaseline = 'top';
    const centerX = w/2;
    const pad = Math.round(h*0.015);
    const lineH = Math.round(h*0.055);
    const boxW = Math.round(w*0.84);
    const boxH = Math.round(lineH*2.2);
    const boxX = Math.round(centerX - boxW/2);
    const boxY = Math.round(h*0.08);
    octx.fillStyle = 'rgba(0,0,0,0.55)';
    octx.roundRect(boxX, boxY, boxW, boxH, Math.round(pad*1.1));
    octx.fill();
    octx.shadowColor = 'rgba(0,0,0,0.6)';
    octx.shadowBlur = Math.round(h*0.01);
    octx.fillStyle = '#ffffff';
    octx.fillText(titleText, centerX, boxY + pad);
    octx.font = Math.round(h*0.06)+'px Montserrat, sans-serif';
    octx.fillStyle = '#ffb74d';
    octx.fillText(scoreText, centerX, boxY + pad + lineH);
    octx.restore();

    // Bepaal highscore
    let highScoreVal = 0;
    try {
      highScoreVal = parseInt(localStorage.getItem('cr_highScore') || '0', 10);
    } catch(e){}

    const numericScore = parseInt(scoreText.replace(/\D+/g,''),10) || 0;
    let extraText = '';
    if (numericScore >= highScoreVal && numericScore > 0){
      extraText = 'NEW PR!';
    }

    // Watermerk & extra tekst rechtsonder
    octx.save();
    octx.textAlign = 'right';
    octx.textBaseline = 'bottom';
    octx.font = Math.round(h*0.03)+'px Montserrat, sans-serif';
    octx.fillStyle = 'rgba(255,255,255,0.92)';
    const stamp = new Date().toLocaleDateString();
    let wmText = 'ASTROVO';
    if (extraText) wmText += ' ‚Ä¢ ' + extraText;
    octx.fillText(wmText + ' ‚Ä¢ ' + stamp, w - Math.round(w*0.02), h - Math.round(h*0.02));
    octx.restore();

    const blob = await new Promise(res => off.toBlob(res, 'image/png'));
    if(!blob){ alert('Kon geen afbeelding maken.'); return; }
    const fileName = `astrovo-score-${Date.now()}.png`;
    const file = new File([blob], fileName, {type:'image/png'});

    if (navigator.canShare && navigator.canShare({files:[file]})) {
      await navigator.share({ title: 'Mijn ASTROVO score', files: [file] });
      return;
    }
    if (navigator.share) {
      const url = URL.createObjectURL(blob);
      try {
        await navigator.share({ title: 'Mijn ASTROVO score', url });
      } finally {
        URL.revokeObjectURL(url);
      }
      return;
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = fileName;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 0);
    alert('Afbeelding gedownload. Je kunt deze nu delen.');
  }catch(err){
    console.error(err);
    alert('Delen mislukt: ' + (err?.message || err));
  }
}

(function(){
  const btns = Array.from(document.querySelectorAll('#shareBtn'));
  if (btns.length > 1){
    for (let i=1;i<btns.length;i++){ btns[i].remove(); }
  }
  const btn = document.getElementById('shareBtn');
  if (btn){
    const fresh = btn.cloneNode(true);
    btn.replaceWith(fresh);
    fresh.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); shareScoreImage(); });
  }
})();

</script>

<!-- Socket.IO + Multiplayer glue -->
<script src="/socket.io/socket.io.js"></script>
<script src="multiplayer.js"></script>


<div id="mpWaiting" style="display:none;position:absolute;inset:0;align-items:center;justify-content:center;text-align:center;background:rgba(0,0,0,0.6);backdrop-filter:blur(6px);z-index:26;">
  <div style="background:rgba(20,20,30,0.95);padding:18px 22px;border-radius:16px;max-width:480px;width:92vw;box-shadow:0 10px 30px rgba(0,0,0,0.45);">
    <h2 style="margin:0 0 4px;">Wachtruimte</h2>
    <p id="mpRoomLabel" style="margin:0 0 10px;opacity:.85;">Kamer: ‚Äî</p>
    <div style="display:flex;gap:8px;justify-content:space-between;margin-bottom:10px;">
      <div style="flex:1;background:#111;border:1px solid #333;border-radius:12px;padding:10px;">
        <div style="opacity:.7;">Speler 1</div>
        <div id="mpP1Name" style="font-weight:600;">‚Äî</div>
        <div id="mpP1Ready" style="margin-top:6px;opacity:.8;">‚è≥ Niet klaar</div>
      </div>
      <div style="flex:1;background:#111;border:1px solid #333;border-radius:12px;padding:10px;">
        <div style="opacity:.7;">Speler 2</div>
        <div id="mpP2Name" style="font-weight:600;">‚Äî</div>
        <div id="mpP2Ready" style="margin-top:6px;opacity:.8;">‚è≥ Niet klaar</div>
      </div>
    </div>
    <div style="display:flex;gap:10px;justify-content:center;">
      <button class="primaryBtn" id="mpReadyBtn">‚úÖ Akkoord</button>
      <button class="secondaryBtn" id="mpLeaveBtn">Terug</button>
    </div>
    <p id="mpWaitingStatus" style="margin-top:10px;opacity:.9;"></p>
  </div>
</div>

</body>
</html>