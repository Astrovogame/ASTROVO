<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
<title>ASTROVO â€” Multiplayer (1v1)</title>
<meta name="theme-color" content="#121212"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#0f0c29;--bg2:#302b63;--bg3:#24243e;
    --accent:#00bcd4;--accent2:#26c6da;--muted:#90a4ae;--danger:#ef5350;--gold:#ffd54f;
  }
  html,body{margin:0;height:100%;font-family:'Montserrat',sans-serif;color:#fff;background:linear-gradient(180deg,var(--bg1) 0%,var(--bg2) 50%,var(--bg3) 100%);}
  #app{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden}
  .frame{position:relative;width:min(100vw,56.25vh);height:calc(min(100vw,56.25vh)*(16/9));}
  canvas{display:block;width:100% !important;height:100% !important;background:transparent;touch-action:none}
  .panel{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;padding:20px;background:rgba(0,0,0,0.35);backdrop-filter:blur(6px)}
  .hidden{display:none !important}
  h1{margin:0 0 8px;font-weight:600;font-size:22px;letter-spacing:.5px}
  input,button{font:inherit}
  input{padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.15);background:rgba(255,255,255,.08);color:#fff;outline:none;min-width:220px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button{padding:10px 14px;border-radius:12px;border:0;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#001018;font-weight:600;cursor:pointer}
  button.secondary{background:rgba(255,255,255,.12);color:#fff}
  #hud{position:absolute;top:10px;left:10px;display:flex;gap:12px;font-weight:600;text-shadow:0 1px 2px rgba(0,0,0,.6)}
  #status{position:absolute;bottom:10px;left:10px;opacity:.8;font-size:12px}
</style>
</head>
<body>
<div id="app">
  <div class="frame">
    <canvas id="game" width="900" height="1600"></canvas>

    <div id="menu" class="panel">
      <h1>ASTROVO â€” Multiplayer (1v1)</h1>
      <div class="row">
        <input id="playerName" placeholder="Jouw naam" maxlength="20"/>
      </div>
      <div class="row">
        <input id="room" placeholder="Room code (bv. 1234)" maxlength="16"/>
      </div>
      <div class="row">
        <button id="createBtn">Create room</button>
        <button id="joinBtn">Join room</button>
      </div>
    </div>

    <div id="lobby" class="panel hidden">
      <h2>Room <span id="roomLabel"></span></h2>
      <div id="playersList" style="margin:6px 0 12px"></div>
      <div class="row">
        <button id="readyBtn">I'm ready</button>
        <button class="secondary" id="leaveBtn">Leave</button>
      </div>
      <p id="lobbyInfo" style="margin-top:10px;opacity:.9">Waiting for both players to readyâ€¦</p>
    </div>

    <div id="overlay" class="panel hidden">
      <h2>Result</h2>
      <p>You: <span id="meScore">0</span> &nbsp;|&nbsp; <span id="oppName">Opponent</span>: <span id="oppScore">0</span></p>
      <div class="row">
        <button id="rematchBtn">Rematch</button>
        <button class="secondary" id="backLobbyBtn">Back to lobby</button>
      </div>
    </div>

    <div id="hud">
      <div>Score: <span id="scoreLbl">0</span></div>
      <div id="opponent">ðŸ†š <span id="oppNameHud">-</span>: <span id="oppScoreHud">0</span></div>
    </div>
    <div id="status"></div>
  </div>
</div>

<script>
// ---- helpers ----
const $=s=>document.querySelector(s);
const el=id=>document.getElementById(id);

// ---- connection & UI ----
const qs = new URLSearchParams(location.search);
const defaultWS = qs.get('ws') || ((location.protocol==='https:'?'wss://':'ws://')+location.host);
let ws=null, myId=null, room=null, playerName='Player', isReady=false;
let opponent = { id:null, name:'-', score:0, alive:true, angle:0 };

function connectWS(url){
  return new Promise((resolve, reject)=>{
    const s = new WebSocket(url);
    let opened=false;
    s.onopen = ()=>{ opened=true; resolve(s); };
    s.onerror = (e)=>{ if(!opened) reject(e); };
    s.onclose = ()=> setStatus('Connection closed');
  });
}
function send(type, data){ if(ws && ws.readyState===1){ ws.send(JSON.stringify({type, ...data})); } }
function setStatus(t){ el('status').textContent = t||''; }

el('createBtn').onclick = async ()=>{
  try{
    ws = await connectWS(defaultWS);
    ws.onmessage = onWS;
  }catch(e){
    alert('Could not connect to '+defaultWS+'\\nMake sure the server is running.');
    return;
  }
  playerName = el('playerName').value.trim() || 'Player';
  room = el('room').value.trim() || ('room'+Math.floor(Math.random()*999));
  send('create',{room, name:playerName});
  enterLobby('host');
};
el('joinBtn').onclick = async ()=>{
  try{
    ws = await connectWS(defaultWS);
    ws.onmessage = onWS;
  }catch(e){
    alert('Could not connect to '+defaultWS+'\\nMake sure the server is running.');
    return;
  }
  playerName = el('playerName').value.trim() || 'Player';
  room = el('room').value.trim();
  if(!room){ alert('Enter a room code'); return; }
  send('join',{room, name:playerName});
  enterLobby('guest');
};
el('leaveBtn').onclick = ()=>{ send('leave',{}); resetToMenu(); };
el('readyBtn').onclick = ()=>{ isReady = !isReady; send('ready',{}); el('readyBtn').textContent=isReady?'Not ready':"I'm ready"; };
el('backLobbyBtn').onclick = ()=>{ overlay.classList.add('hidden'); lobby.classList.remove('hidden'); };
el('rematchBtn').onclick = ()=>{ send('rematch',{}); lobby.classList.remove('hidden'); overlay.classList.add('hidden'); };

function onWS(ev){
  const msg = JSON.parse(ev.data||'{}');
  switch(msg.type){
    case 'hello': myId = msg.id; break;
    case 'roomState': updateRoomUI(msg); break;
    case 'start': startCountdown(msg.t||3, msg.seed, msg.startAt); break;
    case 'broadcast': handleGameSignal(msg.data||{}); break;
  }
}
function updateRoomUI(s){
  const list = (s.players||[]).map(p=> (p.name||'Player') + (p.ready?' âœ…':''));
  el('playersList').textContent = list.join('  â€¢  ');
  if(s.players && s.players.length===2){
    const other = s.players.find(p=>p.id!==myId);
    opponent.id = other.id; opponent.name = other.name; opponent.score = other.score||0; opponent.alive = other.alive!==false;
    el('oppName').textContent = opponent.name;
    el('oppNameHud').textContent = opponent.name;
  }else{
    el('oppNameHud').textContent = '-';
  }
}
function enterLobby(role){
  menu.classList.add('hidden'); lobby.classList.remove('hidden'); overlay.classList.add('hidden');
  el('roomLabel').textContent = room;
  el('readyBtn').textContent="I'm ready"; isReady=false;
}
function resetToMenu(){
  menu.classList.remove('hidden'); lobby.classList.add('hidden'); overlay.classList.add('hidden');
  setStatus('');
  myId=null; room=null; isReady=false; opponent={id:null,name:'-',score:0,alive:true,angle:0};
  try{ ws && ws.close(); }catch{}
}

// ---- game sync ----
function handleGameSignal(d){
  if(d.kind==='pos'){ if(typeof d.angle==='number'){ opponent.angle=d.angle; } if(typeof d.score==='number'){ opponent.score=d.score; el('oppScoreHud').textContent=opponent.score; } }
  if(d.kind==='score'){ opponent.score=d.score; el('oppScoreHud').textContent=opponent.score;
    if(d.coinAngle!==undefined){ // remove coin at angle
      for(let j=coins.length-1;j>=0;j--){
        const c=coins[j]; let diff=Math.abs(c.angle-d.coinAngle); diff=Math.min(diff, Math.PI*2-diff);
        if(diff<1e-3){ coins.splice(j,1); break; }
      }
    }
  }
  if(d.kind==='dead'){ opponent.alive=false; showResult(); }
  if(d.kind==='rematchAck'){ lobby.classList.remove('hidden'); }
}

// ---- Deterministic spawns ----
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,1|t);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296}}
let seed=12345, rng=mulberry32(12345);
let startAt=0;

// ---- Game ----
const canvas = el('game'), ctx = canvas.getContext('2d');
const DESIGN_W=900, DESIGN_H=1600; let w=DESIGN_W,h=DESIGN_H;
function applyCanvasScale(){
  const dpr=Math.max(1,Math.min(3,window.devicePixelRatio||1));
  const cssW = canvas.clientWidth || DESIGN_W;
  const cssH = canvas.clientHeight || DESIGN_H;
  const scale = Math.min(cssW/DESIGN_W, cssH/DESIGN_H);
  canvas.width=Math.floor(cssW*dpr); canvas.height=Math.floor(cssH*dpr);
  ctx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
}
window.addEventListener('resize',applyCanvasScale); applyCanvasScale();

let cx,cy,radius,playerAngle=0,dir=1,baseSpeed=0.018,obstacles=[],coins=[],running=false,score=0;
let obstacleSpeed=4;
// opponent state
let opponentAngle=0; let lastStateSent=0;

canvas.addEventListener('pointerdown', ()=>{ if(running){ dir*=-1; } });

function resetGame(){
  cx=DESIGN_W/2; cy=DESIGN_H/2; radius=Math.min(DESIGN_W,DESIGN_H)*0.45;
  playerAngle=0; dir=1; baseSpeed=0.018; obstacles=[]; coins=[]; score=0; running=false;
  obstacleSpeed = radius/80;
  el('scoreLbl').textContent = '0';
  // roles: based on myId vs opponent.id (string compare gives stable order)
  if(opponent && opponent.id){
    if(myId && myId < opponent.id){ playerAngle = 0; dir=1; opponentAngle = Math.PI; }
    else { playerAngle = Math.PI; dir=-1; opponentAngle = 0; }
  } else {
    opponentAngle = Math.PI; // solo default
  }
  // spawn initial items deterministic
  rng = mulberry32(seed>>>0);
  spawnInitial();
}
function spawnInitial(){
  // coins on ring
  for(let i=0;i<14;i++){
    coins.push({ angle: (rng()*Math.PI*2) });
  }
  // obstacles drifting inward
  for(let i=0;i<10;i++){
    obstacles.push({ angle: rng()*Math.PI*2, dist: radius*(0.4 + 0.6*rng()) });
  }
}

// collision helpers
function angleDist(a,b){ let d=Math.abs(a-b); return Math.min(d, Math.PI*2-d); }

function update(dt){
  if(!running) return;
  // update angles
  const speed = baseSpeed;
  playerAngle = (playerAngle + dir*speed*dt)%(Math.PI*2);
  if(playerAngle<0) playerAngle += Math.PI*2;

  // broadcast my state (throttled)
  if(ws && ws.readyState===1){
    const now=performance.now();
    if(now - lastStateSent > 50){ lastStateSent=now; send('signal', { data:{ kind:'pos', angle:playerAngle, score } }); }
  }

  // move obstacles
  for(const ob of obstacles){ ob.dist -= (dt*0.035*obstacleSpeed); if(ob.dist<radius*0.18){ ob.dist=radius; ob.angle = rng()*Math.PI*2; } }
  // coin pickup
  for(let i=coins.length-1;i>=0;i--){
    const c = coins[i];
    if(angleDist(c.angle, playerAngle) < 0.09){
      coins.splice(i,1);
      score++; el('scoreLbl').textContent=String(score);
      send('signal', { data:{ kind:'score', score, coinAngle: c.angle } });
    }
  }
  // collision with obstacles (dead)
  for(const ob of obstacles){
    if(ob.dist > radius*0.92) continue; // not at ring yet
    if(angleDist(ob.angle, playerAngle) < 0.08){
      running=false;
      send('signal', { data:{ kind:'dead' } });
      showResult();
      break;
    }
  }
}

function startCountdown(t=3, sd=12345, startAtMs=0){
  seed = sd>>>0; startAt = startAtMs||0;
  lobby.classList.add('hidden'); menu.classList.add('hidden'); overlay.classList.add('hidden');
  // simple 3..2..1 overlay
  const div = document.createElement('div');
  div.className='panel'; div.style.background='rgba(0,0,0,0.35)'; div.style.fontSize='64px'; div.style.fontWeight='700';
  div.id='countdown';
  document.querySelector('.frame').appendChild(div);
  let left = t;
  const tick=()=>{
    div.textContent = left<=0 ? 'GO!' : left;
    left--;
    if(left<-1){ div.remove(); beginGame(); } else { setTimeout(tick, 500); }
  };
  tick();
}
function beginGame(){
  resetGame();
  const startDelay = Math.max(0, startAt - Date.now());
  setTimeout(()=>{ running=true; lastTime=performance.now(); frame(); }, startDelay);
}

function showResult(){
  overlay.classList.remove('hidden');
  el('meScore').textContent=score;
  el('oppScore').textContent=opponent.score||0;
}

let lastTime=0;
function frame(ts){
  const now = performance.now();
  const dt = Math.min(50, now - (lastTime||now));
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(frame);
}

// ---- Drawing (match singleplayer style) ----
function drawUFO(ctx, x, y, s, color){
  ctx.save();
  ctx.translate(x,y);
  ctx.scale(s,s);
  // glow
  const glow = ctx.createRadialGradient(0,0,2,  0,0,22);
  glow.addColorStop(0, 'rgba(255,255,255,0.6)');
  glow.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = glow;
  ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
  // base
  const grd = ctx.createLinearGradient(0,-10, 0,14);
  grd.addColorStop(0, '#cfd8dc');
  grd.addColorStop(1, '#607d8b');
  ctx.fillStyle = grd;
  ctx.beginPath(); ctx.ellipse(0, 6, 18, 9, 0, 0, Math.PI*2); ctx.fill();
  // ring band
  ctx.fillStyle = color||'#29b6f6';
  ctx.beginPath(); ctx.ellipse(0, 2, 16, 7, 0, 0, Math.PI*2); ctx.fill();
  // dome
  const dome = ctx.createRadialGradient(-4,-6,2,  0,-8,12);
  dome.addColorStop(0, 'rgba(255,255,255,0.95)');
  dome.addColorStop(1, 'rgba(180,220,255,0.35)');
  ctx.fillStyle = dome;
  ctx.beginPath(); ctx.ellipse(0, -6, 9, 7, 0, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function draw(){
  const w=DESIGN_W, h=DESIGN_H;
  ctx.clearRect(0,0,w,h);
  // ring
  ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=Math.max(18, Math.min(w,h)*0.018);
  ctx.beginPath(); ctx.arc(w/2, h/2, Math.min(w,h)*0.45, 0, Math.PI*2); ctx.stroke();
  const radius=Math.min(w,h)*0.45;
  const cx=w/2, cy=h/2;

  // me
  const px = cx + radius*Math.cos(playerAngle);
  const py = cy + radius*Math.sin(playerAngle);
  drawUFO(ctx, px, py, 1, '#29b6f6');

  // opponent (red UFO)
  const opx = cx + radius*Math.cos(opponent.angle||0);
  const opy = cy + radius*Math.sin(opponent.angle||0);
  drawUFO(ctx, opx, opy, 1, '#ef5350');

  // obstacles
  for(const ob of obstacles){
    const ox = cx + Math.min(ob.dist,radius)*Math.cos(ob.angle);
    const oy = cy + Math.min(ob.dist,radius)*Math.sin(ob.angle);
    ctx.fillStyle='#ef5350';
    ctx.beginPath(); ctx.arc(ox,oy,10,0,Math.PI*2); ctx.fill();
  }

  // coins
  for(const c of coins){
    const cxp = cx + radius*Math.cos(c.angle);
    const cyp = cy + radius*Math.sin(c.angle);
    ctx.fillStyle='#ffd54f'; ctx.beginPath(); ctx.arc(cxp,cyp,8,0,Math.PI*2); ctx.fill();
  }
}

// kick off render loop idle
requestAnimationFrame(frame);
</script>
</body>
</html>
