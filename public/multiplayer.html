<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
<title>ASTROVO â€“ Multiplayer (beta)</title>
<meta name="theme-color" content="#121212"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#0f0c29;--bg2:#302b63;--bg3:#24243e;
    --accent:#ff9800;--accent2:#ffa733;--muted:#78909c;
  }
  html,body{margin:0;height:100%;font-family:'Montserrat',sans-serif;color:#fff;
    background:linear-gradient(180deg,var(--bg1) 0%,var(--bg2) 50%,var(--bg3) 100%);}
  #app{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden}
  .frame{position:relative;width:min(100vw,56.25vh);height:calc(min(100vw,56.25vh)*(16/9));}
  canvas{display:block;width:100% !important;height:100% !important;background:transparent;touch-action:none}
  .panel{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;
    backdrop-filter:blur(6px);background:rgba(0,0,0,.55);padding:20px;text-align:center}
  .hidden{display:none}
  h1{margin:0 0 10px 0;font-weight:600}
  input,button,select{font-family:inherit}
  .row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
  input[type="text"]{padding:10px 12px;border-radius:10px;border:none;min-width:200px}
  button{padding:12px 18px;border:none;border-radius:12px;cursor:pointer;box-shadow:0 4px 8px rgba(0,0,0,.3);
    background:linear-gradient(145deg,var(--accent),var(--accent2));color:#fff;font-size:16px}
  button.secondary{background:linear-gradient(145deg,#607d8b,#78909c)}
  #hud{position:absolute;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;font-weight:600}
  #status{position:absolute;bottom:10px;left:0;right:0;text-align:center;opacity:.9}
  #opponent{opacity:.9}
</style>
</head>
<body>
<div id="app">
  <div class="frame">
    <canvas id="game"></canvas>

    <div id="menu" class="panel">
      <h1>ASTROVO â€” Multiplayer</h1>
      <p style="max-width:560px;opacity:.9">Speel een <b>headâ€‘toâ€‘head</b> race tegen een vriend.
        Jullie spelen dezelfde singleplayerâ€‘game, maar jullie scores worden live gedeeld.
        Eerste met de hoogste score of die het langst overleeft wint.</p>
      <div class="row">
        <input id="playerName" type="text" placeholder="Jouw naam" maxlength="20"/>
        <input id="room" type="text" placeholder="Kamercode (bv. astro123)" maxlength="24"/>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="createBtn">Maak kamer</button>
        <button class="secondary" id="joinBtn">Deelnemen</button>
      </div>
      <p style="margin-top:10px;font-size:14px;opacity:.85">
        Server: <code id="wsUrlLbl"></code>
      </p>
      <p style="margin-top:6px;font-size:13px;opacity:.75">
        Tip: draai <code>ws-server.js</code> lokaal met Node of zet hem online, en open dit bestand via HTTPS/Netlify.
      </p>
    </div>

    <div id="lobby" class="panel hidden">
      <h1>Kamer <span id="roomLabel"></span></h1>
      <div id="playersList" style="margin:6px 0 12px"></div>
      <div class="row">
        <button id="readyBtn">Ik ben klaar</button>
        <button class="secondary" id="leaveBtn">Verlaten</button>
      </div>
      <p id="lobbyInfo" style="margin-top:10px;opacity:.9">Wacht tot beide spelers klaar zijnâ€¦</p>
    </div>

    <div id="countdown" class="panel hidden">
      <h1 id="cd">3</h1>
    </div>

    <div id="overlay" class="panel hidden">
      <h1 id="resultTitle">Eindstand</h1>
      <p id="resultBody">Jij: <span id="meScore">0</span> â€” <span id="oppName">Tegenstander</span>: <span id="oppScore">0</span></p>
      <div class="row">
        <button id="rematchBtn">Nog een potje</button>
        <button class="secondary" id="backLobbyBtn">Terug naar lobby</button>
      </div>
    </div>

    <div id="hud">
      <div>Score: <span id="scoreLbl">0</span></div>
      <div id="opponent">ðŸ†š <span id="oppNameHud">-</span>: <span id="oppScoreHud">0</span></div>
    </div>
    <div id="status"></div>
  </div>
</div>
<script>
// ---- tiny realtime layer (WebSocket relay server) ----
const qs = new URLSearchParams(location.search);
const defaultWS = qs.get('ws') || ((location.protocol==='https:'?'wss://':'ws://')+location.host);
document.getElementById('wsUrlLbl').textContent = defaultWS;
let ws, myId = null, room = null, playerName = '', isReady = false;
let opponent = {id:null, name:'-', score:0, alive:true};

function connectWS(url){
  return new Promise((resolve,reject)=>{
    const s = new WebSocket(url);
    let opened=false;
    s.onopen = ()=>{opened=true; resolve(s)};
    s.onerror = (e)=>{ if(!opened) reject(e); };
    s.onclose = ()=> setStatus('Verbinding gesloten');
  });
}
function send(type, data){ if(ws && ws.readyState===1){ ws.send(JSON.stringify({type, ...data})); } }
function setStatus(t){ document.getElementById('status').textContent = t||''; }

// ---- UI wiring ----
const el = (id)=>document.getElementById(id);
const menu = el('menu'), lobby = el('lobby'), countdown = el('countdown'), overlay = el('overlay');
el('createBtn').onclick = async ()=>{
  await startConn();
  playerName = el('playerName').value.trim() || 'Speler';
  room = el('room').value.trim() || ('room'+Math.floor(Math.random()*999));
  send('create',{room, name:playerName});
  enterLobby('host');
};
el('joinBtn').onclick = async ()=>{
  await startConn();
  playerName = el('playerName').value.trim() || 'Speler';
  room = el('room').value.trim();
  if(!room){ alert('Voer een kamercode in'); return; }
  send('join',{room, name:playerName});
  enterLobby('guest');
};
el('leaveBtn').onclick = ()=>{ send('leave',{}); resetToMenu(); };
el('readyBtn').onclick = ()=>{ isReady = !isReady; send('ready',{ready:isReady}); el('readyBtn').textContent=isReady?'Niet klaar':'Ik ben klaar'; };
el('backLobbyBtn').onclick = ()=>{ overlay.classList.add('hidden'); lobby.classList.remove('hidden'); };
el('rematchBtn').onclick = ()=>{ overlay.classList.add('hidden'); send('rematch',{}); };

function enterLobby(role){
  menu.classList.add('hidden'); lobby.classList.remove('hidden');
  el('roomLabel').textContent = room;
  el('lobbyInfo').textContent = role==='host'?'De host start automatisch zodra beide spelers klaar zijn.':'Wacht op hostâ€¦';
  el('readyBtn').textContent='Ik ben klaar'; isReady=false;
  setStatus('Verbonden als '+playerName);
}
function resetToMenu(){
  menu.classList.remove('hidden'); lobby.classList.add('hidden'); countdown.classList.add('hidden'); overlay.classList.add('hidden');
  setStatus('');
  myId=null; room=null; isReady=false; opponent={id:null,name:'-',score:0,alive:true};
  ws && ws.close();
}
async function startConn(){
  try{
    ws = await connectWS(defaultWS);
    ws.onmessage = onWS;
  }catch(e){
    alert('Kon geen verbinding maken met '+defaultWS+'\\nZorg dat ws-server.js draait.');
    throw e;
  }
}
function onWS(ev){
  const msg = JSON.parse(ev.data||'{}');
  switch(msg.type){
    case 'hello': myId = msg.id; break;
    case 'roomState': updateRoomUI(msg); break;
    case 'start': startCountdown(msg.t||3); break;
    case 'broadcast': handleGameSignal(msg.data||{}); break;
  }
}
function updateRoomUI(s){
  const list = (s.players||[]).map(p=> (p.name||'Speler') + (p.ready?' âœ…':''));
  el('playersList').textContent = list.join('  â€¢  ');
  if(s.players && s.players.length===2){
    const other = s.players.find(p=>p.id!==myId);
    opponent.id = other.id; opponent.name = other.name; opponent.score = other.score||0; opponent.alive = other.alive!==false;
    el('oppName').textContent = opponent.name;
    el('oppNameHud').textContent = opponent.name;
  }else{
    el('oppNameHud').textContent = '-';
  }
}
function handleGameSignal(d){
  if(d.kind==='score'){ opponent.score=d.score; el('oppScoreHud').textContent=opponent.score; }
  if(d.kind==='dead'){ opponent.alive=false; showResult(); }
  if(d.kind==='rematchAck'){ lobby.classList.remove('hidden'); }
}

// ---- Game (lightweight mirror of singleplayer) ----
const canvas = el('game'), ctx = canvas.getContext('2d');
const DESIGN_W=900, DESIGN_H=1600; let w=DESIGN_W,h=DESIGN_H;
function applyCanvasScale(){
  const dpr=Math.max(1,Math.min(3,window.devicePixelRatio||1));
  const vw=canvas.parentElement.clientWidth, vh=canvas.parentElement.clientHeight;
  const scale=Math.min(vw/DESIGN_W, vh/DESIGN_H);
  const cssW=Math.floor(DESIGN_W*scale), cssH=Math.floor(DESIGN_H*scale);
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  canvas.width=Math.floor(cssW*dpr); canvas.height=Math.floor(cssH*dpr);
  ctx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
}
window.addEventListener('resize',applyCanvasScale); applyCanvasScale();

let cx,cy,radius,playerAngle=0,dir=1,baseSpeed=0.018,obstacles=[],coins=[],running=false,score=0,lives=1;
let lastObstacle=0,lastCoin=0,obstacleSpeed=4;
function resetGame(){
  cx=w/2; cy=h/2; radius=Math.min(w,h)*0.45;
  playerAngle=0; dir=1; baseSpeed=0.018; obstacles=[]; coins=[]; score=0; lives=1; running=false;
  lastObstacle=performance.now(); lastCoin=lastObstacle; obstacleSpeed = radius/80;
  el('scoreLbl').textContent='0'; el('oppScoreHud').textContent=opponent.score||0;
}
resetGame();

canvas.addEventListener('pointerdown', ()=>{ if(running){ dir*=-1; } });
function spawnObstacle(){ obstacles.push({angle:Math.random()*Math.PI*2, dist:0, passed:false}); }
function spawnCoin(){ coins.push({angle:Math.random()*Math.PI*2, life:4000}); }

function startCountdown(n){
  countdown.classList.remove('hidden');
  el('cd').textContent=n;
  let t=n;
  const it=setInterval(()=>{
    t--; el('cd').textContent=t;
    if(t<=0){ clearInterval(it); countdown.classList.add('hidden'); startGame(); }
  },1000);
}
function startGame(){ resetGame(); running=true; loopId=requestAnimationFrame(loop); setStatus(''); }
let loopId=0, last=performance.now();
function loop(ts){
  const dt = ts-last; last=ts;
  if(running){ update(dt); draw(); }
  loopId=requestAnimationFrame(loop);
}
function update(dt){
  const now = performance.now();
  playerAngle += dir*baseSpeed;
  if(playerAngle>=Math.PI*2) playerAngle-=Math.PI*2; if(playerAngle<0) playerAngle+=Math.PI*2;

  if(now-lastObstacle>Math.max(1000,4000-score*15)){ spawnObstacle(); lastObstacle=now; }
  if(now-lastCoin>3000){ spawnCoin(); lastCoin=now; }

  // coins
  for(let i=coins.length-1;i>=0;i--){
    const c=coins[i]; c.life-=dt;
    let diff=Math.abs(playerAngle-c.angle); diff=Math.min(diff,Math.PI*2-diff);
    if(diff<0.18){ coins.splice(i,1); score++; el('scoreLbl').textContent=score; send('signal',{room, data:{kind:'score', score}}); }
    else if(c.life<=0){ coins.splice(i,1); }
  }

  // obstacles
  for(let i=obstacles.length-1;i>=0;i--){
    const ob=obstacles[i]; ob.dist += obstacleSpeed;
    if(!ob.passed && ob.dist>=radius){
      let d=Math.abs(playerAngle-ob.angle); d=Math.min(d,Math.PI*2-d);
      if(d<0.25){ // hit
        lives--; running=false; send('signal',{room, data:{kind:'dead'}}); showResult(); return;
      }else{ ob.passed=true; }
    }
    if(ob.dist>radius+40){ obstacles.splice(i,1); }
  }
  baseSpeed = 0.015 + Math.min(0.03, score/4000);
}
function showResult(){
  overlay.classList.remove('hidden');
  el('meScore').textContent=score;
  el('oppScore').textContent=opponent.score||0;
}
function draw(){
  ctx.clearRect(0,0,w,h);
  // ring
  ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=Math.max(18, Math.min(w,h)*0.018);
  ctx.beginPath(); ctx.arc(cx,cy,radius,0,Math.PI*2); ctx.stroke();

  // player
  const px = cx + radius*Math.cos(playerAngle);
  const py = cy + radius*Math.sin(playerAngle);
  ctx.fillStyle='#29b6f6'; ctx.beginPath(); ctx.arc(px,py,14,0,Math.PI*2); ctx.fill();

  // opponent indicator (we only show their score in HUD)

  // obstacles
  for(const ob of obstacles){
    const ox = cx + Math.min(ob.dist,radius)*Math.cos(ob.angle);
    const oy = cy + Math.min(ob.dist,radius)*Math.sin(ob.angle);
    ctx.fillStyle='#ef5350'; ctx.beginPath(); ctx.arc(ox,oy,10,0,Math.PI*2); ctx.fill();
  }

  // coins
  for(const c of coins){
    const cxp = cx + radius*Math.cos(c.angle);
    const cyp = cy + radius*Math.sin(c.angle);
    ctx.fillStyle='#ffd54f'; ctx.beginPath(); ctx.arc(cxp,cyp,8,0,Math.PI*2); ctx.fill();
  }
}
</script>
</body>
</html>
