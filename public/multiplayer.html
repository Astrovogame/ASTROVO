<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
<title>ASTROVO â€” Multiplayer (1v1)</title>
<meta name="theme-color" content="#121212"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#0f0c29;--bg2:#302b63;--bg3:#24243e;
    --accent:#00bcd4;--accent2:#26c6da;--muted:#90a4ae;--danger:#ef5350;--gold:#ffd54f;
  }
  html,body{margin:0;height:100%;font-family:'Montserrat',sans-serif;color:#fff;
    background:linear-gradient(180deg,var(--bg1) 0%,var(--bg2) 50%,var(--bg3) 100%);}
  #app{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden}
  .frame{position:relative;width:min(100vw,56.25vh);height:calc(min(100vw,56.25vh)*(16/9));}
  canvas{display:block;width:100% !important;height:100% !important;background:transparent;touch-action:none}
  .panel{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;
    backdrop-filter:blur(6px);background:rgba(0,0,0,.55);padding:20px;text-align:center}
  .hidden{display:none}
  h1,h2{margin:0 0 10px 0;font-weight:600}
  input,button,select{font-family:inherit}
  .row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
  input[type="text"]{padding:10px 12px;border-radius:10px;border:none;min-width:200px}
  button{padding:12px 18px;border:none;border-radius:12px;cursor:pointer;box-shadow:0 4px 8px rgba(0,0,0,.3);
    background:linear-gradient(145deg,var(--accent),var(--accent2));color:#fff;font-size:16px}
  button.secondary{background:linear-gradient(145deg,#607d8b,#78909c)}
  button.danger{background:linear-gradient(145deg,#c62828,#ef5350)}
  #hud{position:absolute;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;font-weight:600}
  #status{position:absolute;bottom:10px;left:0;right:0;text-align:center;opacity:.9}
</style>
</head>
<body>
<div id="app">
  <div class="frame">
    <canvas id="game"></canvas>

    <!-- Menu -->
    <div id="menu" class="panel">
      <h1>ASTROVO â€” Multiplayer</h1>
      <p style="max-width:560px;opacity:.9">
        Play a <b>1v1 race</b> against a friend. You both play the same game loop with identical spawns.
        Whoever survives the longest (or has the higher score) wins.
      </p>
      <div class="row">
        <input id="playerName" type="text" placeholder="Your name" maxlength="20"/>
        <input id="room" type="text" placeholder="Room code (e.g. astro123)" maxlength="24"/>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="createBtn">Create room</button>
        <button class="secondary" id="joinBtn">Join</button>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="returnBtn" class="danger">Return</button>
      </div>
      <p style="margin-top:10px;font-size:14px;opacity:.85">
        Server: <code id="wsUrlLbl"></code>
      </p>
    </div>

    <!-- Lobby -->
    <div id="lobby" class="panel hidden">
      <h2>Room <span id="roomLabel"></span></h2>
      <div id="playersList" style="margin:6px 0 12px"></div>
      <div class="row">
        <button id="readyBtn">I'm ready</button>
        <button class="secondary" id="leaveBtn">Leave</button>
      </div>
      <p id="lobbyInfo" style="margin-top:10px;opacity:.9">Waiting for both players to readyâ€¦</p>
    </div>

    <!-- Countdown -->
    <div id="countdown" class="panel hidden">
      <h1 id="cd">3</h1>
    </div>

    <!-- Result -->
    <div id="overlay" class="panel hidden">
      <h1 id="resultTitle">Result</h1>
      <p id="resultBody">You: <span id="meScore">0</span> â€” <span id="oppName">Opponent</span>: <span id="oppScore">0</span></p>
      <div class="row">
        <button id="rematchBtn">Rematch</button>
        <button class="secondary" id="backLobbyBtn">Back to lobby</button>
      </div>
    </div>

    <div id="hud">
      <div>Score: <span id="scoreLbl">0</span></div>
      <div id="opponent">ðŸ†š <span id="oppNameHud">-</span>: <span id="oppScoreHud">0</span></div>
    </div>
    <div id="status"></div>
  </div>
</div>
<script>
// ---- connection & UI ----
const qs = new URLSearchParams(location.search);
const defaultWS = qs.get('ws') || ((location.protocol==='https:'?'wss://':'ws://')+location.host);
document.getElementById('wsUrlLbl').textContent = defaultWS;
let ws, myId=null, room=null, playerName='', isReady=false;
let opponent = {id:null, name:'-', score:0, alive:true};

const el = (id)=>document.getElementById(id);
const menu = el('menu'), lobby = el('lobby'), countdown = el('countdown'), overlay = el('overlay');

el('returnBtn').onclick = ()=>{ location.href = 'index.html'; };

async function connectWS(url){
  return new Promise((resolve,reject)=>{
    const s = new WebSocket(url);
    let opened=false;
    s.onopen = ()=>{opened=true; resolve(s)};
    s.onerror = (e)=>{ if(!opened) reject(e); };
    s.onclose = ()=> setStatus('Connection closed');
  });
}
function send(type, data){ if(ws && ws.readyState===1){ ws.send(JSON.stringify({type, ...data})); } }
function setStatus(t){ el('status').textContent = t||''; }

el('createBtn').onclick = async ()=>{
  await startConn();
  playerName = el('playerName').value.trim() || 'Player';
  room = el('room').value.trim() || ('room'+Math.floor(Math.random()*999));
  send('create',{room, name:playerName});
  enterLobby('host');
};
el('joinBtn').onclick = async ()=>{
  await startConn();
  playerName = el('playerName').value.trim() || 'Player';
  room = el('room').value.trim();
  if(!room){ alert('Enter a room code'); return; }
  send('join',{room, name:playerName});
  enterLobby('guest');
};
el('leaveBtn').onclick = ()=>{ send('leave',{}); resetToMenu(); };
el('readyBtn').onclick = ()=>{ isReady = !isReady; send('ready',{ready:isReady}); el('readyBtn').textContent=isReady?'Not ready':"I'm ready"; };
el('backLobbyBtn').onclick = ()=>{ overlay.classList.add('hidden'); lobby.classList.remove('hidden'); };
el('rematchBtn').onclick = ()=>{ overlay.classList.add('hidden'); send('rematch',{}); };

function enterLobby(role){
  menu.classList.add('hidden'); lobby.classList.remove('hidden');
  el('roomLabel').textContent = room;
  el('lobbyInfo').textContent = role==='host'?'The host will auto-start when both are ready.':'Waiting for hostâ€¦';
  el('readyBtn').textContent="I'm ready"; isReady=false;
  setStatus('Connected as '+playerName);
}
function resetToMenu(){
  menu.classList.remove('hidden'); lobby.classList.add('hidden'); countdown.classList.add('hidden'); overlay.classList.add('hidden');
  setStatus('');
  myId=null; room=null; isReady=false; opponent={id:null,name:'-',score:0,alive:true};
  try{ ws && ws.close(); }catch{}
}
async function startConn(){
  try{
    ws = await connectWS(defaultWS);
    ws.onmessage = onWS;
  }catch(e){
    alert('Could not connect to '+defaultWS+'\nMake sure the server is running.');
    throw e;
  }
}
function onWS(ev){
  const msg = JSON.parse(ev.data||'{}');
  switch(msg.type){
    case 'hello': myId = msg.id; break;
    case 'roomState': updateRoomUI(msg); break;
    case 'start': startCountdown(msg.t||3, msg.seed, msg.startAt); break;
    case 'broadcast': handleGameSignal(msg.data||{}); break;
  }
}
function updateRoomUI(s){
  const list = (s.players||[]).map(p=> (p.name||'Player') + (p.ready?' âœ…':''));
  el('playersList').textContent = list.join('  â€¢  ');
  if(s.players && s.players.length===2){
    const other = s.players.find(p=>p.id!==myId);
    opponent.id = other.id; opponent.name = other.name; opponent.score = other.score||0; opponent.alive = other.alive!==false;
    el('oppName').textContent = opponent.name;
    el('oppNameHud').textContent = opponent.name;
  }else{
    el('oppNameHud').textContent = '-';
  }
}
function handleGameSignal(d){
  if(d.kind==='score'){ opponent.score=d.score; el('oppScoreHud').textContent=opponent.score; if(typeof d.coinAngle==='number'){ for(let j=coins.length-1;j>=0;j--){ const cc=coins[j]; let dd=Math.abs(cc.angle - d.coinAngle); dd=Math.min(dd,Math.PI*2-dd); if(dd<1e-3){ coins.splice(j,1); break; } } } }
  if(d.kind==='dead'){ opponent.alive=false; showResult(); }
  if(d.kind==='pos'){ if(typeof d.angle==='number') opponentAngle = d.angle; if(typeof d.score==='number'){ opponent.score = d.score; el('oppScoreHud').textContent=opponent.score; } }
  if(d.kind==='rematchAck'){ lobby.classList.remove('hidden'); }
}

// ---- Deterministic spawns ----
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296}}
let seed=12345, rng=mulberry32(12345);
let startAt=0;

// ---- Game ----
const canvas = el('game'), ctx = canvas.getContext('2d');
const DESIGN_W=900, DESIGN_H=1600; let w=DESIGN_W,h=DESIGN_H;
function applyCanvasScale(){
  const dpr=Math.max(1,Math.min(3,window.devicePixelRatio||1));
  const vw=canvas.parentElement.clientWidth, vh=canvas.parentElement.clientHeight;
  const scale=Math.min(vw/DESIGN_W, vh/DESIGN_H);
  const cssW=Math.floor(DESIGN_W*scale), cssH=Math.floor(DESIGN_H*scale);
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  canvas.width=Math.floor(cssW*dpr); canvas.height=Math.floor(cssH*dpr);
  ctx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
}
window.addEventListener('resize',applyCanvasScale); applyCanvasScale();

let cx,cy,radius,playerAngle=0,dir=1,baseSpeed=0.018,obstacles=[],coins=[],running=false,score=0;
let obstacleSpeed=4;

canvas.addEventListener('pointerdown', ()=>{ if(running){ dir*=-1; } });

function resetGame(){
  cx=w/2; cy=h/2; radius=Math.min(w,h)*0.45;
  // default values
  playerAngle=0; opponentAngle=Math.PI; dir=1; baseSpeed=0.018; obstacles=[]; coins=[]; score=0; running=false;
  obstacleSpeed = radius/80;
  // place players opposite & set opposite directions based on stable id order
  try{
    if(myId && opponent && opponent.id){
      const mine = String(myId), other = String(opponent.id);
      if(mine > other){ // become player 2
        playerAngle = Math.PI; opponentAngle = 0; dir = -1;
      }else{
        playerAngle = 0; opponentAngle = Math.PI; dir = 1;
      }
    }
  }catch{}
  el('scoreLbl').textContent='0'; el('oppScoreHud').textContent=opponent.score||0;
}

function* spawnGenerator(){
  while(true){
    const obDelay = 1100 + (rng()*600|0);
    const coinDelay = 1300 + (rng()*700|0);
    yield {type:'ob', delay:obDelay, angle: rng()*Math.PI*2};
    yield {type:'coin', delay:coinDelay, angle: rng()*Math.PI*2};
  }
}

let spawner, nextSpawnAt=0;
function scheduleSpawns(startMs){
  spawner = spawnGenerator();
  nextSpawnAt = startMs + 600;
}
function processSpawns(now){
  while(now >= nextSpawnAt){
    const s = spawner.next().value;
    if(s.type==='ob') obstacles.push({angle:s.angle, dist:0, passed:false});
    else coins.push({angle:s.angle, life:4000});
    nextSpawnAt += s.delay;
  }
}

function startCountdown(n, srvSeed, srvStartAt){
  seed = (srvSeed|0) || Math.floor(Math.random()*1e9);
  rng = mulberry32(seed);
  startAt = srvStartAt || (Date.now()+n*1000);
  countdown.classList.remove('hidden');
  lobby.classList.add('hidden');
  let t=n;
  el('cd').textContent=t;
  const it=setInterval(()=>{
    t--; el('cd').textContent=t;
    if(t<=0){ clearInterval(it); countdown.classList.add('hidden'); startGame(); }
  },1000);
}
function startGame(){
  resetGame(); running=true; scheduleSpawns(startAt); setStatus('');
  loopId=requestAnimationFrame(loop);
}
let loopId=0, last=performance.now();
function loop(ts){
  const dt = ts-last; last=ts;
  if(running){ update(dt); draw(); }
  loopId=requestAnimationFrame(loop);
}
function update(dt){
  const now = Date.now();
  processSpawns(now);

  \1
  // send position state (throttled)
  if(ws && ws.readyState===1){ const nowSend = performance.now(); if(nowSend - lastStateSent > 50){ lastStateSent = nowSend; send('signal', {room, data:{kind:'pos', angle: playerAngle, score}}); } } 

  for(let i=coins.length-1;i>=0;i--){
    const c=coins[i]; c.life-=dt;
    let diff=Math.abs(playerAngle-c.angle); diff=Math.min(diff,Math.PI*2-diff);
    if(diff<0.18){ coins.splice(i,1); score++; el('scoreLbl').textContent=score; send('signal',{room, data:{kind:'score', score}}); }
    else if(c.life<=0){ coins.splice(i,1); }
  }

  for(let i=obstacles.length-1;i>=0;i--){
    const ob=obstacles[i]; ob.dist += obstacleSpeed;
    if(!ob.passed && ob.dist>=radius){
      let d=Math.abs(playerAngle-ob.angle); d=Math.min(d,Math.PI*2-d);
      if(d<0.25){
        running=false; send('signal',{room, data:{kind:'dead'}}); showResult(); return;
      }else{ ob.passed=true; }
    }
    if(ob.dist>radius+40){ obstacles.splice(i,1); }
  }
  baseSpeed = 0.015 + Math.min(0.03, score/4000);
}
function showResult(){
  overlay.classList.remove('hidden');
  el('meScore').textContent=score;
  el('oppScore').textContent=opponent.score||0;
}

// --- visuals copied from singleplayer ---
function drawPlayerUFO(px, py, baseColor){
  const c=ctx;
  c.save(); c.translate(px,py);
  // glow
  const glow = c.createRadialGradient(0,0,2, 0,0,18);
  glow.addColorStop(0,'rgba(255,255,255,0.6)');
  glow.addColorStop(1,'rgba(255,255,255,0)');
  c.fillStyle = glow; c.beginPath(); c.arc(0,0,18,0,Math.PI*2); c.fill();
  // saucer base
  const grd = c.createLinearGradient(0,-10,0,14);
  grd.addColorStop(0,'#d0d6ff'); grd.addColorStop(1,'#6b78ff');
  c.fillStyle = grd; c.beginPath(); c.ellipse(0,6,16,8,0,0,Math.PI*2); c.fill();
  // colored ring
  c.fillStyle = baseColor || '#29b6f6'; c.beginPath(); c.ellipse(0,2,14,6.5,0,0,Math.PI*2); c.fill();
  // glass dome
  const dome = c.createRadialGradient(-4,-6,2, 0,-8,12);
  dome.addColorStop(0,'rgba(255,255,255,0.95)'); dome.addColorStop(1,'rgba(180,220,255,0.35)');
  c.fillStyle = dome; c.beginPath(); c.ellipse(0,-6,9,7,0,0,Math.PI*2); c.fill();
  // highlight
  c.strokeStyle='rgba(255,255,255,0.65)'; c.lineWidth=1.2; c.beginPath(); c.arc(-3,-8,4,0,Math.PI*1.2); c.stroke();
  c.restore();
}
function drawStarObstacle(ox, oy, outer, inner){
  const c=ctx; c.save(); c.translate(ox,oy);
  c.beginPath();
  for(let i=0;i<10;i++){ const r=(i%2===0)?outer:inner; const ang=i*Math.PI/5; c.lineTo(r*Math.cos(ang), r*Math.sin(ang)); }
  c.closePath();
  const starGrad=c.createRadialGradient(0,0,0, 0,0,outer);
  starGrad.addColorStop(0,'#fffbe6'); starGrad.addColorStop(0.5,'#ffeb3b'); starGrad.addColorStop(1,'#f57f17');
  c.fillStyle=starGrad; c.fill();
  c.restore();
}

function draw(){
  const w=ctx.canvas.width, h=ctx.canvas.height; // device pixels after transform
  ctx.clearRect(0,0,900,1600);
  ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=Math.max(18, Math.min(900,1600)*0.018);
  ctx.beginPath(); ctx.arc(450,800, Math.min(900,1600)*0.45, 0, Math.PI*2); ctx.stroke();
  const radius=Math.min(900,1600)*0.45;
  const cx=450, cy=800;
  const px = cx + radius*Math.cos(playerAngle);
  const py = cy + radius*Math.sin(playerAngle);
  drawPlayerUFO(px, py, '#29b6f6');
  const ox = cx + radius*Math.cos(opponentAngle||0);
  const oy = cy + radius*Math.sin(opponentAngle||0);
  drawPlayerUFO(ox, oy, '#ef5350');
  for(const ob of obstacles){
    const ox = cx + Math.min(ob.dist,radius)*Math.cos(ob.angle);
    const oy = cy + Math.min(ob.dist,radius)*Math.sin(ob.angle);
    drawStarObstacle(ox, oy, Math.max(10, radius*0.022), Math.max(5, radius*0.01));
  }
  for(const c of coins){
    const cxp = cx + radius*Math.cos(c.angle);
    const cyp = cy + radius*Math.sin(c.angle);
    const cr = Math.max(8, radius*0.014);
    const g = ctx.createRadialGradient(cxp - cr*0.3, cyp - cr*0.3, cr*0.3, cxp, cyp, cr);
    g.addColorStop(0,'#fff8e1'); g.addColorStop(0.5,'#ffd54f'); g.addColorStop(1,'#ffb300');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cxp,cyp,cr,0,Math.PI*2); ctx.fill();
  }
}
</script>
</body>
</html>
