<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>ASTROVO – één‑vinger arcade (1v1)</title>
  <link rel="manifest" href="manifest_circle.json">
  <meta name="theme-color" content="#121212">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
  <style>
    html,body{margin:0;padding:0;height:100%;background:linear-gradient(180deg,#0f0c29 0%,#302b63 50%,#24243e 100%);color:#fff;font-family:'Montserrat',sans-serif;overflow:hidden}
    #app{position:fixed;inset:0;display:grid;place-items:center}
    .phone{position:relative;width:min(100vw,56.25vh);height:calc(min(100vw,56.25vh)*(16/9));max-height:100vh;max-width:100vw}
    canvas{display:block;width:100%!important;height:100%!important;background:transparent;touch-action:none}
    .btn{margin:8px;padding:14px 32px;font-size:20px;border:none;border-radius:12px;cursor:pointer;box-shadow:0 4px 8px rgba(0,0,0,.3);background:linear-gradient(145deg,#607d8b,#78909c);color:#fff}
    .btn.primary{background:linear-gradient(145deg,#ff9800,#ffa733)}
    #start{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;background:rgba(0,0,0,.5);backdrop-filter:blur(6px)}
    #start h1{font-size:54px;margin:0 0 10px}
    #stats{opacity:.85;margin-bottom:8px}
    #pause{position:absolute;top:max(12px,env(safe-area-inset-top));right:max(12px,env(safe-area-inset-right));width:48px;height:48px;border:none;border-radius:12px;background:rgba(0,0,0,.45);color:#fff;font-size:22px;display:none}
    .overlay{position:absolute;inset:0;display:none;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.6);backdrop-filter:blur(6px);text-align:center}
    #multiForm .card{background:rgba(20,20,30,.92);padding:16px 18px;border-radius:14px;width:min(420px,92vw);box-shadow:0 10px 30px rgba(0,0,0,.55)}
    .field{display:flex;flex-direction:column;gap:6px;margin:8px 0}
    input[type=text]{padding:10px 12px;border-radius:10px;border:1px solid #444;background:#101321;color:#fff;font-size:16px}
    .row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
    .tag{font-size:14px;opacity:.8;margin-top:6px}
  </style>
</head>
<body>
<div id="app"><div class="phone"><canvas id="game"></canvas>
  <button id="pause">⏸</button>

  <div id="start">
    <h1>ASTROVO</h1>
    <div id="stats"></div>
    <button class="btn primary" id="startSolo">Start</button>
    <button class="btn" id="openMulti">Multiplayer</button>
  </div>

  <div class="overlay" id="gameOver">
    <h2 id="goTitle">Game Over</h2>
    <div id="goScore"></div>
    <div id="goCoins"></div>
    <div class="row">
      <button class="btn primary" id="restart">Opnieuw</button>
      <button class="btn" id="toMenu">Menu</button>
    </div>
  </div>

  <div class="overlay" id="multiForm">
    <div class="card">
      <h2>1v1 Multiplayer</h2>
      <div class="field">
        <label>Naam</label>
        <input type="text" id="playerName" maxlength="16" placeholder="Jouw naam">
      </div>
      <div class="field">
        <label>Kamercode (bijv. ABC123)</label>
        <input type="text" id="roomCode" maxlength="12" placeholder="Code">
      </div>
      <div class="row">
        <button class="btn primary" id="joinRoom">Join</button>
        <button class="btn" id="cancelMulti">Annuleren</button>
      </div>
      <div class="tag">Tip: Deel dezelfde code met je tegenstander. Max. 2 spelers.</div>
      <div id="multiMsg" class="tag"></div>
    </div>
  </div>

  <div class="overlay" id="waiting">
    <h2>Wachten op tegenstander…</h2>
    <div id="waitMsg" class="tag"></div>
    <button class="btn" id="leaveRoom">Annuleren</button>
  </div>
</div></div>

<script>
// ---------------------- Utilities ----------------------
function clamp(n,a,b){return Math.max(a,Math.min(b,n));}
function hashString(s){ // simple 32-bit hash
  let h=2166136261>>>0;
  for(let i=0;i<s.length;i++){h^=s.charCodeAt(i);h=(h>>>0)*16777619>>>0;}
  return h>>>0;
}
function makeRNG(seed){
  let x = seed>>>0 || 123456789;
  return function(){
    // xorshift32
    x ^= x << 13; x >>>= 0;
    x ^= x >> 17; x >>>= 0;
    x ^= x << 5;  x >>>= 0;
    return ((x>>>0) / 0xFFFFFFFF);
  }
}

// ---------------------- Canvas sizing ----------------------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let DESIGN_W=900, DESIGN_H=1600;
function fit(){
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
  const vw=window.innerWidth, vh=window.innerHeight;
  const scale = Math.min(vw/DESIGN_W, vh/DESIGN_H);
  const cssW=Math.floor(DESIGN_W*scale), cssH=Math.floor(DESIGN_H*scale);
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  canvas.width=Math.floor(cssW*dpr); canvas.height=Math.floor(cssH*dpr);
  ctx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
}
window.addEventListener('resize', fit); fit();

// ---------------------- Game state ----------------------
let cx=DESIGN_W/2, cy=DESIGN_H/2, radius=Math.min(DESIGN_W,DESIGN_H)*0.45;
let playerAngle=0, direction=1, baseSpeed=0.015;
let obstacles=[], coins=[], powerUps=[], score=0;
let lives=1, running=false, paused=false;
let coinBank=parseInt(localStorage.getItem('cr_coins')||'0',10);
let highScore=parseInt(localStorage.getItem('cr_highScore')||'0',10);
let collectedCoins=0;
let explosions=[], particles=[], trail=[];
let rng=Math.random; // will be replaced when playing

function resetLocalState(){
  playerAngle=0; direction=1; baseSpeed=0.015;
  obstacles=[]; coins=[]; powerUps=[]; score=0; lives=1;
  explosions=[]; particles=[]; trail=[]; collectedCoins=0;
}

// ---------------------- Spawning (deterministic) ----------------------
let lastObstacleSpawn=0, lastCoinSpawn=0, nextPowerUpTime=12000;
function spawnObstacle(){
  const angle = rng()*Math.PI*2;
  obstacles.push({angle, distance:0, passed:false});
}
function spawnCoin(){
  const angle = rng()*Math.PI*2;
  coins.push({angle, life:4000});
}
function spawnPowerUp(){
  const angle = rng()*Math.PI*2;
  const type = (rng()<0.5)?'slow':'shield';
  powerUps.push({angle, life:4000, type});
}

// ---------------------- Rendering helpers (minimal) ----------------------
function drawRing(){
  ctx.lineWidth = 18;
  const grad = ctx.createRadialGradient(cx,cy,radius-18,cx,cy,radius+18);
  grad.addColorStop(0,'rgba(255,255,255,.18)');
  grad.addColorStop(1,'rgba(0,0,0,.5)');
  ctx.strokeStyle=grad;
  ctx.beginPath(); ctx.arc(cx,cy,radius,0,Math.PI*2); ctx.stroke();
}
function drawUFO(x,y,baseColor){
  ctx.save();
  ctx.translate(x,y);
  // dome
  ctx.fillStyle='rgba(255,255,255,.9)';
  ctx.beginPath(); ctx.ellipse(0,-10,18,12,0,0,Math.PI*2); ctx.fill();
  // hull
  const g = ctx.createLinearGradient(-26,0,26,0);
  g.addColorStop(0,'#111'); g.addColorStop(1,'#333');
  ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(0,0,26,14,0,0,Math.PI*2); ctx.fill();
  // glow
  ctx.fillStyle=baseColor; ctx.globalAlpha=0.8;
  ctx.beginPath(); ctx.ellipse(0,8,30,6,0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function drawObstacle(angle,dist){
  const x=cx+dist*Math.cos(angle), y=cy+dist*Math.sin(angle);
  ctx.fillStyle='#ff7043';
  ctx.beginPath(); ctx.arc(x,y,8,0,Math.PI*2); ctx.fill();
}
function drawPickup(angle,color){
  const x=cx+radius*Math.cos(angle), y=cy+radius*Math.sin(angle);
  ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,7,0,Math.PI*2); ctx.fill();
}

// ---------------------- Input ----------------------
canvas.addEventListener('pointerdown', ()=>{
  if(!running) return;
  direction *= -1;
  // notify peer
  if (net.playing) sendWS({type:'toggle'});
});

// ---------------------- UI elements ----------------------
const start = document.getElementById('start');
const startSolo = document.getElementById('startSolo');
const stats = document.getElementById('stats');
const pauseBtn = document.getElementById('pause');
const gameOver = document.getElementById('gameOver');
const goScore = document.getElementById('goScore');
const goCoins = document.getElementById('goCoins');
const restartBtn = document.getElementById('restart');
const toMenu = document.getElementById('toMenu');
const openMulti = document.getElementById('openMulti');
const multiForm = document.getElementById('multiForm');
const waiting = document.getElementById('waiting');
const playerNameEl = document.getElementById('playerName');
const roomCodeEl = document.getElementById('roomCode');
const joinRoomBtn = document.getElementById('joinRoom');
const cancelMulti = document.getElementById('cancelMulti');
const multiMsg = document.getElementById('multiMsg');
const leaveRoomBtn = document.getElementById('leaveRoom');
const waitMsg = document.getElementById('waitMsg');

function show(el){el.style.display='flex';}
function hide(el){el.style.display='none';}

function refreshStats(){
  stats.textContent = `High score: ${highScore} • Coins: ${coinBank}`;
}
refreshStats();

startSolo.onclick = () => {
  startSingleplayer();
};
openMulti.onclick = ()=>{ show(multiForm); };
cancelMulti.onclick = ()=>{ hide(multiForm); };
toMenu.onclick = ()=>{ hide(gameOver); show(start); refreshStats(); };
restartBtn.onclick = ()=>{ hide(gameOver); startSingleplayer(); };

// ---------------------- Solo ----------------------
let gameStartAt=0;
function startSingleplayer(){
  rng = Math.random; // normal randomness
  resetLocalState();
  lastObstacleSpawn=0; lastCoinSpawn=0; nextPowerUpTime=12000;
  gameStartAt = performance.now();
  running=true; hide(start); hide(gameOver); hide(waiting); hide(multiForm);
  loopId || requestAnimationFrame(loop);
}

function onDeath(){
  running=false;
  coinBank += collectedCoins; localStorage.setItem('cr_coins', coinBank);
  highScore = Math.max(highScore, score); localStorage.setItem('cr_highScore', highScore);
  goScore.textContent = `Score: ${score}`;
  goCoins.textContent = `Coins deze run: ${collectedCoins}`;
  show(gameOver);
}

// ---------------------- Multiplayer (WS relay) ----------------------
const net = {
  ws:null, room:null, name:'', playing:false, isHost:false,
  opp:{ name:'?', angle:0, alive:true, color:'#e53935' },
};
function connectWS(){
  const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
  const url = `${proto}://${location.host}`;
  const ws = new WebSocket(url);
  ws.onopen = ()=>{};
  ws.onclose = ()=>{ if(net.playing){ alert('Verbinding verbroken.'); resetNet(); } };
  ws.onmessage = (ev)=>{
    let msg = {}; try{ msg=JSON.parse(ev.data);}catch{}
    const t = msg.type;
    if (t==='joined'){
      waiting.style.display='flex';
      waitMsg.textContent = 'Je zit in de kamer. Wacht op tegenstander…';
    }
    if (t==='peer-joined'){
      // Start protocol: host decides start time/seed
      if (!net.isHost) return;
      const startIn = 1500;
      const startTime = Date.now() + startIn;
      const seed = hashString(net.room);
      sendWS({type:'start', startTime, seed});
    }
    if (t==='start'){
      // Both players set rng/clock and begin
      const { startTime, seed } = msg;
      rng = makeRNG(seed>>>0);
      gameStartAt = startTime;
      startMultiplayer();
    }
    if (t==='state'){
      net.opp.angle = msg.angle;
      net.opp.alive = msg.alive;
      if (msg.name) net.opp.name = msg.name;
    }
    if (t==='toggle'){
      // nothing to do; we already just use angle/state messages
    }
    if (t==='dead'){
      // opponent died; if we're alive we will win when we outlive them
      net.opp.alive = false;
    }
    if (t==='peer-left'){
      alert('Tegenstander heeft de kamer verlaten.');
      resetNet(); show(start);
    }
    if (t==='full'){
      multiMsg.textContent = 'Kamer vol. Kies een andere code.';
      if(net.ws) {try{net.ws.close();}catch{}}
      resetNet();
    }
    if (t==='error'){
      multiMsg.textContent = msg.message || 'Er ging iets mis.';
    }
  };
  net.ws = ws;
}
function sendWS(obj){ try{ net.ws && net.ws.readyState===1 && net.ws.send(JSON.stringify(obj)); }catch{} }
function resetNet(){
  net.playing=false; net.room=null; net.isHost=false;
  try{ net.ws && net.ws.close(); }catch{} net.ws=null;
}

joinRoomBtn.onclick = ()=>{
  const name = (playerNameEl.value || 'Player').slice(0,16);
  const code = (roomCodeEl.value || '').trim().toUpperCase();
  if (!code) { multiMsg.textContent='Vul een code in.'; return; }
  net.name = name; net.room = code;
  net.isHost = true; // first joiner becomes host; server will tell second peer joined
  connectWS();
  sendWS({type:'join', code});
  hide(multiForm);
  show(waiting);
};

leaveRoomBtn.onclick = ()=>{
  resetNet();
  hide(waiting);
};

function startMultiplayer(){
  hide(waiting); hide(start); hide(gameOver);
  resetLocalState();
  lastObstacleSpawn=0; lastCoinSpawn=0; nextPowerUpTime=12000;
  running=true; net.playing=true;
  loopId || requestAnimationFrame(loop);
  // Send our name once
  sendWS({type:'state', name: net.name, angle: playerAngle, alive: true});
}

// In MP we simulate identical world using rng seeded from room code and the same start time.
// We also stream our state ~20 times per second.
let stateSendAcc = 0;

// ---------------------- Main loop ----------------------
let prevTs=null, loopId=null;
function loop(ts){
  loopId = null;
  if (!running) { prevTs = ts; return; }
  const dt = prevTs? (ts - prevTs) : 16.7; prevTs = ts;

  // Time since gameStartAt for deterministic spawns in MP
  const nowMs = (net.playing ? (Date.now()) : ts);
  const elapsed = (nowMs - gameStartAt);
  // Spawn logic (based on elapsed + score, deterministic because rng is seeded)
  const obstacleInterval = Math.max(1000, 4000 - score * 15);
  if (elapsed - lastObstacleSpawn > obstacleInterval){
    const spawnCount = Math.min(1 + Math.floor(score / 15), 4);
    for (let j=0;j<spawnCount;j++) spawnObstacle();
    lastObstacleSpawn = elapsed;
  }
  if (elapsed - lastCoinSpawn > 3000){ spawnCoin(); lastCoinSpawn=elapsed; }
  if (elapsed > nextPowerUpTime){ spawnPowerUp(); nextPowerUpTime = elapsed + (12000 + rng()*6000); }

  // Update player
  playerAngle += direction * baseSpeed;
  if (playerAngle >= Math.PI*2) playerAngle -= Math.PI*2;
  if (playerAngle < 0) playerAngle += Math.PI*2;

  // Update coins
  for (let i=coins.length-1;i>=0;i--){
    const c=coins[i];
    c.life -= dt;
    if (c.life<=0){ coins.splice(i,1); continue; }
    let diff = Math.abs(playerAngle - c.angle); diff = Math.min(diff, Math.PI*2 - diff);
    if (diff < 0.18){ coins.splice(i,1); collectedCoins += 1; }
  }

  // Obstacles move outwards
  const obstacleSpeed = radius/80;
  for (let i=obstacles.length-1;i>=0;i--){
    const ob=obstacles[i];
    ob.distance += obstacleSpeed;
    if (!ob.passed && ob.distance >= radius){
      let diff = Math.abs(playerAngle - ob.angle); diff = Math.min(diff, Math.PI*2 - diff);
      if (diff < 0.25){
        // collision
        if (lives>0){ lives--; obstacles.splice(i,1); }
        if (lives<=0){
          // death
          running=false;
          if (net.playing){ sendWS({type:'dead'}); }
          onDeath();
          requestAnimationFrame(loop);
          return;
        }
      } else {
        ob.passed = true; score++;
      }
    }
    if (ob.distance > radius + 30) obstacles.splice(i,1);
  }

  // Send state in MP
  if (net.playing){
    stateSendAcc += dt;
    if (stateSendAcc > 50){ // ~20 Hz
      stateSendAcc = 0;
      sendWS({type:'state', angle: playerAngle, alive: lives>0 });
    }
  }

  // Render
  ctx.clearRect(0,0,DESIGN_W,DESIGN_H);
  drawRing();
  // coins & powerups
  coins.forEach(c => drawPickup(c.angle,'#ffd54f'));
  powerUps.forEach(p => drawPickup(p.angle, p.type==='slow' ? '#81d4fa' : '#ba68c8'));
  // obstacles
  obstacles.forEach(o => drawObstacle(o.angle, o.distance));
  // players
  const px = cx + radius*Math.cos(playerAngle);
  const py = cy + radius*Math.sin(playerAngle);
  drawUFO(px, py, '#29b6f6'); // you
  if (net.playing){
    const ox = cx + radius*Math.cos(net.opp.angle);
    const oy = cy + radius*Math.sin(net.opp.angle);
    drawUFO(ox, oy, net.opp.color);
    // names
    ctx.fillStyle='rgba(255,255,255,.9)'; ctx.font='16px Montserrat';
    ctx.textAlign='center'; ctx.fillText(net.name, px, py-34);
    ctx.fillStyle='rgba(255,120,120,.9)'; ctx.fillText(net.opp.name, ox, oy-34);
  }
  // HUD
  ctx.fillStyle='rgba(255,255,255,.9)';
  ctx.font='24px Montserrat';
  ctx.textAlign='left'; ctx.fillText(`Score: ${score}`, 16, 34);

  // Next
  loopId = requestAnimationFrame(loop);
}

</script>
</body>
</html>
